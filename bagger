#!/usr/bin/env bash

# Enable BASH 4's globstar
shopt -s globstar

# Enable colors
BOLD_BLUE="\033[1;34m"
BOLD_GREEN="\033[1;32m"
BOLD_RED="\033[31m"
CYAN="\033[36m"
MAGENTA="\033[35m"
YELLOW="\033[33m"
NORMAL="\033[0m"

#------------------------------------------------------------------
#   FUNCTIONS
#------------------------------------------------------------------

#  SCREEN MANIPULATION
#==============================================
__save_screen () {
	printf "\033[?1049h"
}

__restore_screen () {
	printf "\033[r\033[?1049l"
}

__clear_screen () {
	printf "\033[H\033[2J"
}
__place_cursor () {
	printf "\033[${1};${2}H"
}

__clear_line () {
	printf "\033[K"
}

#  BANNERS
#==============================================
__top_banner () {
	printf "${BOLD_GREEN}%52s\r%s${CYAN}%s${NORMAL}\n" \
	"${flac_directories[${current_directory}]##*/}" " " "[$(( ${current_directory} + 1 ))/${number_of_directories}]"

	# Separator line
	printf "%s${BOLD_BLUE}%s${NORMAL}\n" " " "───────┬────────────────┬──────────────────────────"
}


__album_banner () {
	printf "%8s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\n" \
	"" "│" " " "Album Metadata" " " "│"

	printf "%8s${BOLD_BLUE}%s${NORMAL}\n" \
	"" "└────────────────┘"
}

__track_banner () {
	printf "%s${BOLD_BLUE}%s${NORMAL}\n" \
	" " "──┬───────────────────────────┬────────────────────"

	printf "%3s${BOLD_BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}\n" \
	"" "│" " " "Individual Track Metadata" " " "│"

	printf "%3s${BOLD_BLUE}%s${NORMAL}\n" \
	"" "└───────────────────────────┘"
}

#  ALBUM MANIPULATION
#==============================================
__display_album_tags () {
	# Store all the tag metadata into an array
	album_metadata_array=( ARTIST ALBUM DISCNUMBER DATE TRACKTOTAL GENRE RELEASETYPE SOURCE MASTERING )

	# Pick the first FLAC file in the current directory and display all the
	# tags that will be changed album-wise (multiple tag)
	for first_flac in "${album_flacs_array[0]}" ; do

		# Artist Tag
		ARTIST="$(metaflac --show-tag=ARTIST "${first_flac}")"
		ARTIST="${ARTIST#*=}"

		# Album Tag
		ALBUM="$(metaflac --show-tag=ALBUM "${first_flac}")"
		ALBUM="${ALBUM#*=}"

		# Discnumber Tag
		DISCNUMBER="$(metaflac --show-tag=DISCNUMBER "${first_flac}")"
		DISCNUMBER="${DISCNUMBER#*=}"

		# Date Tag
		DATE="$(metaflac --show-tag=DATE "${first_flac}")"
		DATE="${DATE#*=}"

		# Tracktotal Tag
		TRACKTOTAL="$(metaflac --show-tag=TRACKTOTAL "${first_flac}")"
		TRACKTOTAL="${TRACKTOTAL#*=}"

		# Genre Tag
		GENRE="$(metaflac --show-tag=GENRE "${first_flac}")"
		GENRE="${GENRE#*=}"

		# ReleaseType Tag
		RELEASETYPE="$(metaflac --show-tag=RELEASETYPE "${first_flac}")"
		RELEASETYPE="${RELEASETYPE#*=}"

		# Source Tag
		SOURCE="$(metaflac --show-tag=SOURCE "${first_flac}")"
		SOURCE="${SOURCE#*=}"

		# Mastering Tag
		MASTERING="$(metaflac --show-tag=MASTERING "${first_flac}")"
		MASTERING="${MASTERING#*=}"

		# Go through each tag field and print the tag field as well as the current
		# value for that field
		for album_tag in "${!album_metadata_array[@]}" ; do

			# Set up spacing for each tag field
			case "${album_metadata_array[${album_tag}]}" in
				ARTIST)
					SPACING="9"
				;;
				ALBUM)
					SPACING="10"
				;;
				DISCNUMBER)
					SPACING="5"
				;;
				DATE)
					SPACING="11"
				;;
				TRACKTOTAL)
					SPACING="5"
				;;
				GENRE)
					SPACING="10"
				;;
				RELEASETYPE)
					SPACING="4"
				;;
				SOURCE)
					SPACING="9"
				;;
				MASTERING)
					SPACING="6"
				;;
			esac

			# If album tag value is null display <empty>, else display current value
			if [[ -z "${!album_metadata_array[${album_tag}]}" ]] ; then
				printf "%${SPACING}s${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}\n" \
				"" "${album_metadata_array[${album_tag}]}:" " " "<empty>"
			else
				printf "%${SPACING}s${CYAN}%s${NORMAL}%s\n" \
				"" "${album_metadata_array[${album_tag}]}:" " ${!album_metadata_array[${album_tag}]}"
			fi

		done
	done
}

# Display each tag field with a prompt to the user to
# "possibly" change the current tag using BASH's builtin
# support for GNU readline
__change_album_tags () {
	# Go through each tag field and display a prompt to the user
	# asking for a (possible) new tag value. Then, save the new
	# value.
	#
	# Also, display current tag being edited (UI enhancements)
	for album_tag in "${!album_metadata_array[@]}" ; do

		# Set up spacing for the arrow displayed before
		# each tag field as well as set up spacing for each
		# tag field displayed as a prompt and initialize
		# the new tag fields to be saved
		case "${album_metadata_array[${album_tag}]}" in
			ARTIST)
				# Tag spacing
				spacing="9"

				# Spacing for arrow ( -> )
				arrow_spacing="7"

				# Initialize placeholder variable that the new
				# tag will reside (if applicable)
				new_artist="dont tag"
			;;
			ALBUM)
				# Tag spacing
				spacing="10"

				# Spacing for arrow ( -> )
				arrow_spacing="8"

				# Initialize placeholder variable that the new
				# tag will reside (if applicable)
				new_album="dont tag"
			;;
			DISCNUMBER)
				# Tag spacing
				spacing="5"

				# Spacing for arrow ( -> )
				arrow_spacing="3"

				# Initialize placeholder variable that the new
				# tag will reside (if applicable)
				new_discnumber="dont tag"
			;;
			DATE)
				# Tag spacing
				spacing="11"

				# Spacing for arrow ( -> )
				arrow_spacing="9"

				# Initialize placeholder variable that the new
				# tag will reside (if applicable)
				new_date="dont tag"
			;;
			TRACKTOTAL)
				# Tag spacing
				spacing="5"

				# Spacing for arrow ( -> )
				arrow_spacing="3"

				# Initialize placeholder variable that the new
				# tag will reside (if applicable)
				new_tracktotal="dont tag"
			;;
			GENRE)
				# Tag spacing
				spacing="10"

				# Spacing for arrow ( -> )
				arrow_spacing="8"

				# Initialize placeholder variable that the new
				# tag will reside (if applicable)
				new_genre="dont tag"
			;;
			RELEASETYPE)
				# Tag spacing
				spacing="4"

				# Spacing for arrow ( -> )
				arrow_spacing="2"

				# Initialize placeholder variable that the new
				# tag will reside (if applicable)
				new_releasetype="dont tag"
			;;
			SOURCE)
				# Tag spacing
				spacing="9"

				# Spacing for arrow ( -> )
				arrow_spacing="7"

				# Initialize placeholder variable that the new
				# tag will reside (if applicable)
				new_source="dont tag"
			;;
			MASTERING)
				# Tag spacing
				spacing="6"

				# Spacing for arrow ( -> )
				arrow_spacing="4"

				# Initialize placeholder variable that the new
				# tag will reside (if applicable)
				new_mastering="dont tag"
			;;
		esac

		# Place cursor to current tag
		__place_cursor "${current_line}" "${arrow_spacing}"

		# Display arrow before current tag showing focus
		printf "${BOLD_GREEN}%s${NORMAL}" "->"

		# Place cursor back at the bottom
		__place_cursor "${total_lines}" 0
	
		printf "%${spacing}s${CYAN}%s${NORMAL}" \
		"" "${album_metadata_array[${album_tag}]}:"

		# Read in the new tag from the user with a prompt
		read -r -e -i "${!album_metadata_array[${album_tag}]}" -p " " new_tag

		__place_cursor "${current_line}" "${arrow_spacing}"

		# If the old tag is different from the new one
		if [[ "${!album_metadata_array[${album_tag}]}" != "${new_tag}" ]] ; then

			# If the old tag is empty
			if [[ -z "${!album_metadata_array[${album_tag}]}" ]] ; then
				printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}%s${BOLD_RED}%s${NORMAL}" \
				" " "*" " " "${album_metadata_array[${album_tag}]}:" " " "${new_tag}" " <- " "<empty>"

			# If the new tag is empty
			elif [[ -z "${new_tag}" ]] ; then
				printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${BOLD_RED}%s${NORMAL}" \
				" " "*" " " "${album_metadata_array[${album_tag}]}:" " " "<empty>"

			# Display the old tag and the new tag differences
			else
				printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}%s${BOLD_RED}%s${NORMAL}" \
				" " "*" " " "${album_metadata_array[${album_tag}]}:" " " "${new_tag}" " <- " "${!album_metadata_array[${album_tag}]}"
			fi

		# If the old and new tag are the same and the new
		# tag is empty
		elif [[ -z "${new_tag}" ]] ; then
			printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${BOLD_RED}%s${NORMAL}" \
			" " "*" " " "${album_metadata_array[${album_tag}]}:" " " "<empty>"

		# No difference from old tag to new tag, change the tag color
		# to green
		else
			printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}" \
			" " "*" " " "${album_metadata_array[${album_tag}]}:" " " "${!album_metadata_array[${album_tag}]}"
		fi

		# If the value of the new tag is different from the old tag, save the
		# new metadata, else skip it (this allows us to NOT retag files unnecessarily)
		if [[ "${!album_metadata_array[${album_tag}]}" != "${new_tag}" ]] ; then

			# Save the new tag value to be used when tagging
			# the files
			case "${album_metadata_array[${album_tag}]}" in
				ARTIST)
					new_artist="${new_tag}"
				;;
				ALBUM)
					new_album="${new_tag}"
				;;
				DISCNUMBER)
					new_discnumber="${new_tag}"
				;;
				DATE)
					new_date="${new_tag}"
				;;
				TRACKTOTAL)
					new_tracktotal="${new_tag}"
				;;
				GENRE)
					new_genre="${new_tag}"
				;;
				RELEASETYPE)
					new_releasetype="${new_tag}"
				;;
				SOURCE)
					new_source="${new_tag}"
				;;
				MASTERING)
					new_mastering="${new_tag}"
				;;
			esac

		fi

		__place_cursor "${total_lines}" 0
		__clear_line
		((current_line++))

	done
}

#  TRACK MANIPULATION
#==============================================
# Obtain the song length of the current FLAC file
__song_length () {
	# Obtain the total number of samples in current file
    total_samples="$(metaflac --show-total-samples "${album_flacs_array[${flac}]}")"

    # Obtain the sample rate in current file
    sample_rate="$(metaflac --show-sample-rate "${album_flacs_array[${flac}]}")"

    # This the total number of time in minutes (with the decimal [seconds]
    # moved to the right 3 places to account for non integer division
    total_time_in_minutes_with_decimal_moved="$(( ${total_samples} * 1000 / ${sample_rate} / 60 ))"

    # This is the total number of minutes (moves the decimal
    # back to the left 3 places and culls the 'decimal')
    total_minutes="$(( ${total_time_in_minutes_with_decimal_moved} / 1000 ))"

    # If the song is really short (less than a minute, do not offset the
    # string when obtaining just the remaining song time
    #
    # This is essentiall a percentage decimal (eg .832) but with the
    # decimal moved 3 places to the right
    if [[ "${total_minutes}" -eq 0 ]] ; then
        remaining_time_decimal_percentage="${total_time_in_minutes_with_decimal_moved}"
    else
        remaining_time_decimal_percentage="${total_time_in_minutes_with_decimal_moved:${#total_minutes}}"
    fi

    # Remove any leading zeroes from the remaining time so BASH can
    # successfully multiply the time without thinking the number is
    # an octal number
    #
    # (eg. 078 -> 78 or 008 -> 08)
    remaining_time_decimal_percentage="${remaining_time_decimal_percentage#0}"
    # (eg. 08 -> 8)
    remaining_time_decimal_percentage="${remaining_time_decimal_percentage#0}"

    # This is the remaining time 'percentage' multiplied by 60 to obtain the
    # total seconds (again, the decimal is moved 3 places to the right)
    remaining_seconds_unformatted="$(( ${remaining_time_decimal_percentage} * 60 ))"

    # Check the string length of the remaining seconds and prepend
    # the necessary amount of zeroes to ensure we always end
    # up with exactly five (5) characters (for consistency)
    case "${#remaining_seconds_unformatted}" in
        5)
            # Do nothing
            :
        ;;
        4)
            remaining_seconds_unformatted="0${remaining_seconds_unformatted}"
        ;;
        3)
            remaining_seconds_unformatted="00${remaining_seconds_unformatted}"
        ;;
        2)
            remaining_seconds_unformatted="000${remaining_seconds_unformatted}"
        ;;
        1)
            remaining_seconds_unformatted="0000${remaining_seconds_unformatted}"
        ;;
        0)
            remaining_seconds_unformatted="00000${remaining_seconds_unformatted}"
        ;;
        *)
            # Should NOT ever happen
            printf "%s\n" "This is a bug!"
            exit 1
        ;;
    esac

    # This is the total number of seconds obtained from the
    # above string: ${remaining_seconds_unformatted}, with the
    # extra 'decimal places' removed
    total_seconds="${remaining_seconds_unformatted:0:2}"

    # This is the value right after the remaining seconds last
    # digit, essentially a decimal number.  This will be
    # used to round up or down.
    round_up_value="${remaining_seconds_unformatted:2:1}"

    # If ${round_up_value} is greater or equal to five (5),
    # round up by adding one to the total seconds
    if [[ "${round_up_value}" -ge 5 ]] ; then
        total_seconds="${total_seconds#0}"
        ((total_seconds++))
    fi

    # If the total seconds is only one digit (eg. 0-9), then
    # prepend a zero in front to allow consistent spacing
    if [[ "${#total_seconds}" -eq 1 ]] ; then
        total_seconds="0${total_seconds}"
    fi

    # If the total seconds is 60 (as a result of rounding up),
    # then set the total seconds to '00' (for formatting) and add
    # one to the total minutes
    if [[ "${total_seconds}" == "60" ]] ; then
        total_seconds=00
        ((total_minutes++))
    fi

    # This will print the resultant song length
    printf "%s" "${total_minutes}:${total_seconds}"
}

# List the FLAC files in the current directory with
# the song length of each FLAC file
__list_tracks () {
	for flac in "${!album_flacs_array[@]}" ; do
		# Print current FLAC file with song length
		LENGTH="$(__song_length)"
		printf "\r\033[K%s${BOLD_BLUE}%s${NORMAL}%s\n" \
		"    " "${LENGTH}" " ${album_flacs_array[${flac}]##*/}"
	done
}

__reset_track_listing () {
	# Reset ${current_line} to previous value
	current_line="${current_line_backup}"

	# Reset ${total_lines} to previous value
	total_lines="${total_lines_backup}"

	# This is the total # of lines to erase
	lines_to_move_up="$(( ${#album_flacs_array[@]} + 2 ))"

	# Travel up each line (to remove) and clear it
	for (( line=0 ; line < ${lines_to_move_up} ; line++ )) ; do
		printf "\033[A\033[K"
	done
}

#  RETAGGING
#==============================================
__retag_album () {
	# Only set tags if there was a new tag specified (eg. ${new_artist} deesn't
	# equal "dont tag"), otherwise skip tagging for that specific field and continue on

	# Set new ARTIST tag
	if [[ "${new_artist}" != "dont tag" ]] ; then
		metaflac --remove-tag=ARTIST "${flac_directories[${current_directory}]}"/*.[Ff][Ll][Aa][Cc]
		metaflac --set-tag=ARTIST="${new_artist}" "${flac_directories[${current_directory}]}"/*.[Ff][Ll][Aa][Cc]
	fi

	# Set new ALBUM tag
	if [[ "${new_album}" != "dont tag" ]] ; then
		metaflac --remove-tag=ALBUM "${flac_directories[${current_directory}]}"/*.[Ff][Ll][Aa][Cc]
		metaflac --set-tag=ALBUM="${new_album}" "${flac_directories[${current_directory}]}"/*.[Ff][Ll][Aa][Cc]
	fi

	# Set new DISCNUMBER tag
	if [[ "${new_discnumber}" != "dont tag" ]] ; then
		metaflac --remove-tag=DISCNUMBER "${flac_directories[${current_directory}]}"/*.[Ff][Ll][Aa][Cc]
		metaflac --set-tag=DISCNUMBER="${new_discnumber}" "${flac_directories[${current_directory}]}"/*.[Ff][Ll][Aa][Cc]
	fi

	# Set new DATE tag
	if [[ "${new_date}" != "dont tag" ]] ; then
		metaflac --remove-tag=DATE "${flac_directories[${current_directory}]}"/*.[Ff][Ll][Aa][Cc]
		metaflac --set-tag=DATE="${new_date}" "${flac_directories[${current_directory}]}"/*.[Ff][Ll][Aa][Cc]
	fi

	# Set new TRACKTOTAL tag
	if [[ "${new_tracktotal}" != "dont tag" ]] ; then
		metaflac --remove-tag=TRACKTOTAL "${flac_directories[${current_directory}]}"/*.[Ff][Ll][Aa][Cc]
		metaflac --set-tag=TRACKTOTAL="${new_tracktotal}" "${flac_directories[${current_directory}]}"/*.[Ff][Ll][Aa][Cc]
	fi

	# Set new GENRE tag
	if [[ "${new_genre}" != "dont tag" ]] ; then
		metaflac --remove-tag=GENRE "${flac_directories[${current_directory}]}"/*.[Ff][Ll][Aa][Cc]
		metaflac --set-tag=GENRE="${new_genre}" "${flac_directories[${current_directory}]}"/*.[Ff][Ll][Aa][Cc]
	fi

	# Set new RELEASETYPE tag
	if [[ "${new_releasetype}" != "dont tag" ]] ; then
		metaflac --remove-tag=RELEASETYPE "${flac_directories[${current_directory}]}"/*.[Ff][Ll][Aa][Cc]
		metaflac --set-tag=RELEASETYPE="${new_releasetype}" "${flac_directories[${current_directory}]}"/*.[Ff][Ll][Aa][Cc]
	fi

	# Set new SOURCE tag
	if [[ "${new_source}" != "dont tag" ]] ; then
		metaflac --remove-tag=SOURCE "${flac_directories[${current_directory}]}"/*.[Ff][Ll][Aa][Cc]
		metaflac --set-tag=SOURCE="${new_source}" "${flac_directories[${current_directory}]}"/*.[Ff][Ll][Aa][Cc]
	fi

	# Set new MASTERING tag
	if [[ "${new_mastering}" != "dont tag" ]] ; then
		metaflac --remove-tag=MASTERING "${flac_directories[${current_directory}]}"/*.[Ff][Ll][Aa][Cc]
		metaflac --set-tag=MASTERING="${new_mastering}" "${flac_directories[${current_directory}]}"/*.[Ff][Ll][Aa][Cc]
	fi
}

__retag_tracks () {
	# Only set tags if there was a new tag specified, otherwise skip tagging
	# for that specific field and continue on
	for flac in "${!album_flacs_array[@]}" ; do
	
		# Current FLAC file
		current_flac="${album_flacs_array[${flac}]##*/}"

		# Grab the TRACKNUMBER and TITLE tags from the current FLAC file
		# via the associate array: ${track_metadata_array[@]}.
		tracknumber_tag="${track_metadata_array[${current_flac}_tracknumber]}"
		title_tag="${track_metadata_array[${current_flac}_title]}"

		# Set new TRACKNUMBER tag
		if [[ -n "${tracknumber_tag}" ]] ; then
			metaflac --remove-tag=TRACKNUMBER "${album_flacs_array[${flac}]}"
			metaflac --set-tag=TRACKNUMBER="${tracknumber_tag}" "${album_flacs_array[${flac}]}"
		fi

		# Set new TITLE tag
		if [[ -n "${title_tag}" ]] ; then
			metaflac --remove-tag=TITLE "${album_flacs_array[${flac}]}"
			metaflac --set-tag=TITLE="${title_tag}" "${album_flacs_array[${flac}]}"
		fi
	done
}

#  PROMPTS
#==============================================
__save_album_tags_prompt () {
	printf "%s${CYAN}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}%s${BOLD_RED}%s${NORMAL}%s" \
	" Save " "album" " METADATA? [" "Yes" "/" "No" "] "
	while read -e -r ; do
		case "${REPLY}" in
			[Yy] | "")
				retag_album="true"
				break
			;;
			[Yy][Ee][Ss])
				retag_album="true"
				break
			;;
			[Nn])
				retag_album="false"
				break
			;;
			[Nn][Oo])
				retag_album="false"
				break
			;;
			*)
				printf "%s\n" "Unknown answer: ${REPLY}. Exiting..."
				exit 1
			;;
		esac
	done
}

__save_track_tags_prompt () {
	printf "\n\033[K%s${CYAN}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}%s${BOLD_RED}%s${NORMAL}%s" \
	" Save " "track" " METADATA? [" "Yes" "/" "No" "] "
	while read -e -r ; do
		case "${REPLY}" in
			[Yy] | "")
				retag_tracks="true"
				break
			;;
			[Yy][Ee][Ss])
				retag_tracks="true"
				break
			;;
			[Nn])
				retag_tracks="false"
				break
			;;
			[Nn][Oo])
				retag_tracks="false"
				break
			;;
			*)
				printf "%s\n" "Unknown answer: ${REPLY}. Exiting..."
				exit 1
			;;
		esac
	done
}

__tag_directory_final_prompt () {
	# Separator line
	printf "%s${BOLD_RED}%s${NORMAL}\n" " " "▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄"

	# The total number of lines to be used so far
	total_lines=$(( ${current_line} + 4 ))

	# Place the next separator line below the upcoming prompt
	__place_cursor "${total_lines}" 0

	# Separator line
	printf "%s${BOLD_RED}%s${NORMAL}\n" " " "▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀"

	# Return the cursor positions to where it would normally
	# be (after the first separator line
	__place_cursor "$(( ${total_lines} - 1 ))" 0

	# Prompt
	printf "%s${CYAN}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}%s${BOLD_RED}%s${NORMAL}%s" \
	" Tag " "all" " files in current directory? [" "Yes" "/" "No" "] "

	# Place the next separator line below the upcoming prompt
	__place_cursor "$(( ${total_lines} - 1 ))" 47

	while read -r ; do
		case "${REPLY}" in
			"" | [Yy] | [Yy][Ee][Ss])
				__retag_album
				__retag_tracks

				# Unset variables
				unset retag_album
				unset retag_tracks

				printf "\n"

				break
			;;
			[Nn])
				printf "\n"

				# Restore screen settings
				__restore_screen

				exit 1
			;;
			[Nn][Oo])
				printf "\n"

				# Restore screen settings
				__restore_screen

				exit 1
			;;
			*)
				printf "\n%s\n" "Unknown answer: ${REPLY}. Exiting..."

				# Restore screen settings
				__restore_screen

				exit 1
			;;
		esac
	done

}
#------------------------------------------------------------------


#------------------------------------------------------------------
#   BEGIN SCRIPT
#------------------------------------------------------------------
# Save screen settings
__save_screen

# This is the directory to process FLACs
directory="${1%/}"

# Find all the FLAC files and store in an array
total_flacs_array=( "${directory}"/**/*.[Ff][Ll][Aa][Cc] )

# Find all the directories to process (ie. albums)
for i in "${total_flacs_array[@]}" ; do

	# If the current directory is not equal to the last
	# processed directory, then save it to an array as
	# a new directory
	if [[ "${processed_directory}" != "${i%/*}" ]] ; then
		flac_directories+=( "${i%/*}" )
	fi

	# Save current directory into variable for testing on
	# next iteration
	processed_directory="${i%/*}"

done

# Grab the number of directories found to process
number_of_directories="${#flac_directories[@]}"

# This will iterate through each directory and on each
# directory, do some processing
for current_directory in "${!flac_directories[@]}" ; do

	#------------------------------------------------------------------
	#   ALBUM METADATA
	#------------------------------------------------------------------
	# Until user chooses "yes" at the prompt to save
	# album metadata, don't move on to track metadata
	until [[ "${retag_album}" == "true" ]] ; do

		# Find all the FLAC files in the current processed directory
		album_flacs_array=( "${flac_directories[${current_directory}]}"/**/*.[Ff][Ll][Aa][Cc] )

		# Clear the screen
		__clear_screen

		# Display current directory
		__top_banner

		# Show album banner
		__album_banner

		# Total lines used so far in the header/banner, including
		# the start of the first tag field
		total_lines="4"

		# Display the album metadata with the current
		# tags found for each field
		__display_album_tags

		# Separator line
		printf "%s${BOLD_BLUE}%s${NORMAL}\n" \
		" " "───────────────────────────────────────────────────"

		# Total number of lines used thus far (banner, tag fields, spacing)
		total_lines=15

		# The current line is the current tag field being processed (with ->)
		# used in the below function when reading/setting new tags
		current_line=5

		# Display each album tag field with user prompt
		__change_album_tags

		# Prompt user whether album metadata should be saved and
		# continue with the file metadata
		__save_album_tags_prompt

	done
	#------------------------------------------------------------------


	#------------------------------------------------------------------
	#   TRACK METADATA
	#------------------------------------------------------------------
	# Show track banner
	__track_banner

	# The current line is the total lines so far (without the FLAC file
	# listing plus 4 for spacing)
	current_line="$(( ${total_lines} + 4 ))"

	# Backup to the above, to allow correct lines if user specifies
	# no to prompts
	current_line_backup="${current_line}"

	# Total number of lines used thus far (banner, tag fields,
	# spacing, # of flac files)
	total_lines="$(( ${total_lines} + ${#album_flacs_array[@]} + 5 ))"

	# Backup to the above, to allow correct lines if user specifies
	# no to prompts
	total_lines_backup="${total_lines}"

	# Until user chooses "yes" at the prompt to save
	# track metadata, don't move on to final prompt
	until [[ "${retag_tracks}" == "true" ]] ; do

		# If user said no for previous prompt, clear the lines
		# displayed (individual tracks) and start the tagging
		# process over
		if [[ "${retag_tracks}" == "false" ]] ; then
			__reset_track_listing
		fi

		# Show a listing of FLAC files in current directory
		__list_tracks

		# Separator line
		printf "%s${BOLD_BLUE}%s${NORMAL}\n" \
		" " "───────────────────────────────────────────────────"

		#------------------------------------------------------------------
		#   CHANGE TRACK TAGS VIA USER PROMPT
		#------------------------------------------------------------------
		# This _CANNOT_ be in a separate function, since the associative
		# array at the bottom of the 'for' loop won't be availabe when
		# trying to retag the files via '__retag_tracks' function

		# Display each track tag field to change with user prompt
		for flac in "${!album_flacs_array[@]}" ; do

			# Declare an associative array to catalogue which files
			# have which tags added
			declare -A track_metadata_array

			# Print current FLAC file with song length
			LENGTH="$(__song_length)"

			__place_cursor "${current_line}" 2
			printf "${BOLD_GREEN}%s${NORMAL}" "->"
			__place_cursor "${total_lines}" 0

			# Tracknumber Tag
			TRACKNUMBER="$(metaflac --show-tag=TRACKNUMBER "${album_flacs_array[${flac}]}")"
			TRACKNUMBER="${TRACKNUMBER#*=}"

			# Title Tag
			TITLE="$(metaflac --show-tag=TITLE "${album_flacs_array[${flac}]}")"
			TITLE="${TITLE#*=}"

			printf "\r\033[K%s${CYAN}%s${NORMAL}" \
			" " "TRACKNUMBER / TITLE:"

			# Read in new tracknumber and title tag via prompt
			#
			# If TRACKNUMBER and TITLE are both empty, don't display
			# either tag (prevents space between two tags from appearing)
			if [[ -z "${TRACKNUMBER}" && -z "${TITLE}" ]] ; then
				read -r -e -a tracknumber_title_array -p " "

			# If TRACKNUMBER is empty, just display TITLE tag
			elif [[ -z "${TRACKNUMBER}" ]] ; then
				read -r -e -a tracknumber_title_array -i "${TITLE}" -p " "

			# Display both tags.  If TITLE is empty, the spacing will still
			# be correct (eg. '01 ' < space after track number)
			else
				read -r -e -a tracknumber_title_array -i "${TRACKNUMBER} ${TITLE}" -p " "
			fi

			# Check to make sure tracknumber tag is a valid
			# tracknumber (integer) that is either 1 or 2 digits
			case "${tracknumber_title_array[0]}" in

				# Valid tracknumber (single digit so prepend a 0)
				[0-9])
					new_tracknumber="0${tracknumber_title_array[0]}"
					new_title="${tracknumber_title_array[@]:1}"
				;;

				# Valid tracknumber (double digit)
				[0-9][0-9])
					new_tracknumber="${tracknumber_title_array[0]}"
					new_title="${tracknumber_title_array[@]:1}"
				;;

				# Invalid tracknumber
				*)
					new_tracknumber=""
					new_title="${tracknumber_title_array[@]}"
				;;

			esac

			__place_cursor "${current_line}" 0

			# If both the new tags are NOT empty
			if [[ -n "${new_tracknumber}" && -n "${new_title}" ]] ; then
				printf "\r\033[K%s${MAGENTA}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}\n" \
				"  " "*" " " "${LENGTH}" " [ " "${new_tracknumber}" " ] " "${new_title}"

			# If the new tracknumber tag is empty
			elif [[ -z "${new_tracknumber}" && -n "${new_title}" ]] ; then
				printf "\r\033[K%s${MAGENTA}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_RED}%s${NORMAL}%s${BOLD_GREEN}%s${NORMAL}\n" \
				"  " "*" " " "${LENGTH}" " [ " "??" " ] " "${new_title}"

			# If the new title tag is empty
			elif [[ -n "${new_tracknumber}" && -z "${new_title}" ]] ; then
				printf "\r\033[K%s${MAGENTA}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${BOLD_RED}%s${NORMAL}\n" \
				"  " "*" " " "${LENGTH}" " [ " "${new_tracknumber}" " ] " "<empty>"

			# If both tags are empty
			else
				printf "\r\033[K%s${MAGENTA}%s${NORMAL}%s${BOLD_BLUE}%s${NORMAL}%s${BOLD_RED}%s${NORMAL}%s${BOLD_RED}%s${NORMAL}\n" \
				"  " "*" " " "${LENGTH}" " [ " "??" " ] " "<empty>"
			fi

			((current_line++))

			# Set the new metadata into the associative array for processing later
			# only if the user set a NEW tag
			#
			# TRACKNUMBER
			#if [[ -n "${new_tracknumber}" && "${new_tracknumber}" != "${TRACKNUMBER}" ]] ; then
				track_metadata_array+=( ["${album_flacs_array[${flac}]##*/}_tracknumber"]="${new_tracknumber}" )
			#fi

			# TITLE
			#if [[ -n "${new_title}" && "${new_title}" != "${TITLE}" ]] ; then
				track_metadata_array+=( ["${album_flacs_array[${flac}]##*/}_title"]="${new_title}" )
			#fi

		done
		#------------------------------------------------------------------

		# Prompt user whether file metadata should be saved
		# continuing on with final prompt
		__save_track_tags_prompt

	done
	#------------------------------------------------------------------


	#------------------------------------------------------------------
	#   FINAL PROMPT
	#------------------------------------------------------------------
	# Final prompt to decide whether metadata should be
	# applied to all files in the current directory
	__tag_directory_final_prompt
	#------------------------------------------------------------------

done

# Restore screen settings
__restore_screen

#------------------------------------------------------------------
#   END SCRIPT
#------------------------------------------------------------------
exit 0
