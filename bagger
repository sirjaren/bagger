#!/usr/bin/env bash

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You can follow development of this script on Github at:
# https://github.com/sirjaren/bagger
#
# Please submit requests/changes/patches and/or comments
#-----------------------------------------------------------------

# Enable BASH 4's globstar
shopt -s globstar

# Script version
VERSION="0.2"

# Enable colors
BLUE="\033[34m"
GREEN="\033[32m"
RED="\033[31m"
CYAN="\033[36m"
MAGENTA="\033[35m"
YELLOW="\033[33m"
NORMAL="\033[0m"

# This is where the renamed music files/directories
# will be moved to
rename_directory="/media/Music_Library/Music/No Artwork"

#------------------------------------------------------------------
#   FUNCTIONS
#------------------------------------------------------------------

#  DISPLAY VERSION
#==============================================
__version () {
	printf "%s\n" "Version: ${VERSION}"
}

#  SCREEN MANIPULATION
#==============================================
__save_screen () {
	printf "\033[?1049h"
}

__restore_screen () {
	printf "\033[r\033[?1049l"
}

__clear_screen () {
	printf "\033[H\033[2J"
}
__place_cursor () {
	printf "\033[${1};${2}H"
}

__clear_line () {
	printf "\033[K"
}

#  BANNERS
#==============================================
__top_banner () {
	printf "${GREEN}%52s\r%s${CYAN}%s${NORMAL}\n" \
	"${flac_directories[${current_directory}]##*/}" " " "[$(( ${current_directory} + 1 ))/${number_of_directories}]"
}


__album_banner () {
	# Separator line
	printf "%s${BLUE}%s${NORMAL}\n" \
	" " "───────┬────────────────┬──────────────────────────"

	printf "%8s${BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BLUE}%s${NORMAL}\n" \
	"" "│" " " "Album Metadata" " " "│"

	printf "%8s${BLUE}%s${NORMAL}\n" \
	"" "└────────────────┘"
}

__multi_banner () {
	# Separator line
	printf "%s${BLUE}%s${NORMAL}\n" \
	" " "───────┬────────────────────────┬──────────────────────────"

	printf "%8s${BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BLUE}%s${NORMAL}\n" \
	"" "│" " " "Multiple Disc Metadata" " " "│"

	printf "%8s${BLUE}%s${NORMAL}\n" \
	"" "└────────────────────────┘"
}

__track_banner () {
	printf "%s${BLUE}%s${NORMAL}\n" \
	" " "──┬───────────────────────────┬────────────────────"

	printf "%3s${BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BLUE}%s${NORMAL}\n" \
	"" "│" " " "Individual Track Metadata" " " "│"

	printf "%3s${BLUE}%s${NORMAL}\n" \
	"" "└───────────────────────────┘"
}

#  ALBUM MANIPULATION
#==============================================
__display_album_tags () {
	# Store all the tag fields into an array
	album_tag_field_array=( ARTIST ALBUM DISCNUMBER DATE TRACKTOTAL GENRE RELEASETYPE SOURCE MASTERING )

	# Go through each FLAC file in the current directory and obtain all the
	# tags that will be changed album-wise (batch tag).
	mapfile -n0 -t metaflac_tag_array < \
	<(metaflac \
		--show-bps \
		--show-sample-rate \
		--show-tag=ARTIST \
		--show-tag=ALBUM \
		--show-tag=DISCNUMBER \
		--show-tag=DATE \
		--show-tag=TRACKTOTAL \
		--show-tag=GENRE \
		--show-tag=RELEASETYPE \
		--show-tag=SOURCE \
		--show-tag=MASTERING \
		"${album_flacs_array[@]}"
	)

	# For each tag field (eg. ARTIST, DATE, etc), test for a value in one of the FLAC files
	# in the current directory.  If the specified tag is found, start looking for the next
	# tag field's value.  If a tag cannot found, try the next file (continuing on until all
	# the files have been tried).
	for tag_field in "${!album_tag_field_array[@]}" ; do

		# ${tag} is a value like: ARTIST=Kamelot
		for tag in "${metaflac_tag_array[@]##*.[Ff][Ll][Aa][Cc]:}" ; do

			# Removes tag value from ${tag}
			# (eg. ARTIST=Kamelot -> ARTIST)
			current_tag_field="${tag%=*}"

			# If the current tag field from the top most for loop is the same as
			# the ${current_tag_field} variable (upper case), then test for the
			# tag value from that field.
			if [[ "${album_tag_field_array[${tag_field}]}" == "${current_tag_field^^}" ]] ; then

				# If tag value exists, store it in the appropriate tag
				# field
				if [[ -n "${tag#*=}" ]] ; then

					case "${album_tag_field_array[${tag_field}]}" in
						ARTIST)
							ARTIST="${tag#*=}"
							break
						;;
						ALBUM)
							ALBUM="${tag#*=}"
							break
						;;
						DISCNUMBER)
							DISCNUMBER="${tag#*=}"
							# ${previous_discnumber_value} is used to determine if there are
							# multiple values of DISCNUMBER in one directory, indicating
							# a possible multi-disc album
							if [[ "${DISCNUMBER}" != "${previous_discnumber_value}" && -n "${previous_discnumber_value}" ]] ; then
								DISCNUMBER="<multiple discs>"
								break
							fi
							previous_discnumber_value="${DISCNUMBER}"
						;;
						DATE)
							DATE="${tag#*=}"
							break
						;;
						TRACKTOTAL)
							TRACKTOTAL="${tag#*=}"
							break
						;;
						GENRE)
							GENRE="${tag#*=}"
							break
						;;
						RELEASETYPE)
							RELEASETYPE="${tag#*=}"
							break
						;;
						SOURCE)
							SOURCE="${tag#*=}"
							break
						;;
						MASTERING)
							MASTERING="${tag#*=}"
							break
						;;
						*)
							# The 'bps' and 'sample-rate' would
							# appear here, so do nothing
							:
						;;
					esac
				fi
			fi
		done
	done

	# Go through each tag field and print the tag field as well as the current
	# value for that field
	for tag_field in "${!album_tag_field_array[@]}" ; do

		# Set up spacing for each tag field
		case "${album_tag_field_array[${tag_field}]}" in
			ARTIST)
				SPACING="9"
			;;
			ALBUM)
				SPACING="10"
			;;
			DISCNUMBER)
				SPACING="5"
			;;
			DATE)
				SPACING="11"
			;;
			TRACKTOTAL)
				SPACING="5"
			;;
			GENRE)
				SPACING="10"
			;;
			RELEASETYPE)
				SPACING="4"
			;;
			SOURCE)
				SPACING="9"
			;;
			MASTERING)
				SPACING="6"
			;;
		esac

		# If the current tag field is ALBUM, check if the bits per sample and
		# sample rate are higher than CD quality (greater than 16bit/44.1kHz).
		# If so, display the album field with a yellow prompt showing the values
		# of the bps as well as sample rate (indicating a vinyl or digital release).
		if [[ "${album_tag_field_array[${tag_field}]}" == "ALBUM" ]] ; then

			# These two values are ALWAYS going to be the
			# first to array indices. Make sure to remove the
			# filename before saving the values
			bits_per_sample="${metaflac_tag_array[0]##*:}"
			sample_rate="${metaflac_tag_array[1]##*:}"

			if [[ "${bits_per_sample}" -gt 16 || "${sample_rate}" -gt 44100 ]] ; then
				# Change sample rate value from Hz to kHz
				case "${sample_rate}" in
					8000)
						sample_rate="8"
					;;
					11025)
						sample_rate="11.025"
					;;
					12000)
						sample_rate="12"
					;;
					16000)
						sample_rate="16"
					;;
					18900)
						sample_rate="18.9"
					;;
					22050)
						sample_rate="22.05"
					;;
					24000)
						sample_rate="24"
					;;
					28000)
						sample_rate="28"
					;;
					32000)
						sample_rate="32"
					;;
					37800)
						sample_rate="37.8"
					;;
					44100)
						sample_rate="44.1"
					;;
					48000)
						sample_rate="48"
					;;
					56000)
						sample_rate="56"
					;;
					64000)
						sample_rate="64"
					;;
					88200)
						sample_rate="88.2"
					;;
					96000)
						sample_rate="96"
					;;
					112000)
						sample_rate="112"
					;;
					128000)
						sample_rate="128"
					;;
					144000)
						sample_rate="144"
					;;
					176400)
						sample_rate="176.4"
					;;
					192000)
						sample_rate="192"
					;;
				esac

				# Display ALBUM value with yellow values of bps and sample rate
				printf "%${SPACING}s${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s${RED}%s${YELLOW}%s${RED}%s${NORMAL}\n" \
				"" "ALBUM:" " " "${ALBUM}" "  " "*" "${bits_per_sample}bit/${sample_rate}kHz" "*"
			else
				if [[ -z "${ALBUM}" ]] ; then
					# Null, display: '<empty>'
					printf "%${SPACING}s${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}\n" \
					"" "ALBUM:" " " "<empty>"
				else
					# Display normal ALBUM: with ALBUM value
					printf "%${SPACING}s${CYAN}%s${NORMAL}%s\n" \
					"" "ALBUM:" " ${ALBUM}"
				fi
			fi

		# If the current tag field is DISCNUMBER, display whether there are
		# multiple flacs containing different values for DISCNUMBER (indicating
		# a multi-disc release).  If all the same, either display <empty>
		# or the tag value
		elif [[ "${album_tag_field_array[${tag_field}]}" == "DISCNUMBER" ]] ; then

			if [[ -z "${DISCNUMBER}" ]] ; then
				# Display '<empty>'
				printf "%${SPACING}s${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}\n" \
				"" "DISCNUMBER:" " " "<empty>"
			elif [[ "${DISCNUMBER}" == "<multiple discs>" ]] ; then
				# Display '<multiple discs>'
				printf "%${SPACING}s${CYAN}%s${NORMAL}%s${YELLOW}%s${NORMAL}\n" \
				"" "DISCNUMBER:" " " "<multiple discs>"
			else
				# Not empty, display DISCNUMBER value
				printf "%${SPACING}s${CYAN}%s${NORMAL}%s${NORMAL}%s${NORMAL}\n" \
				"" "DISCNUMBER:" " " "${DISCNUMBER}"
			fi

		# If the current tag field is TRACKTOTAL, display the value obtained
		# from the FLAC file as well as the value determined from the number
		# of FLAC files
		elif [[ "${album_tag_field_array[${tag_field}]}" == "TRACKTOTAL" ]] ; then

			# If TRACKTOTAL is NOT equal to the # of FLAC files in the
			# current directory, display the # of FLAC files as well
			if [[ -n "${TRACKTOTAL}" && "${TRACKTOTAL}" != "${#album_flacs_array[@]}" ]] ; then
				# Display TRACKTOTAL value and # of FLAC files
				printf "%${SPACING}s${CYAN}%s${NORMAL}%s${RED}%s${YELLOW}%s${RED}%s${NORMAL}\n" \
				"" "TRACKTOTAL:" " ${TRACKTOTAL}  " "*" "${#album_flacs_array[@]} songs found" "*"
			elif [[ -z "${TRACKTOTAL}" ]] ; then
				# Display '<empty>' and # of FLAC files
				printf "%${SPACING}s${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s${RED}%s${YELLOW}%s${RED}%s${NORMAL}\n" \
				"" "TRACKTOTAL:" " " "<empty>" "  " "*" "${#album_flacs_array[@]} songs found" "*"
			else
				# Not empty, and TRACKTOTAL equals # of FLAC files
				printf "%${SPACING}s${CYAN}%s${NORMAL}%s\n" \
				"" "TRACKTOTAL:" " ${TRACKTOTAL}"
			fi

		# If other tag field's values are null, display <empty>, else display current value
		elif [[ -z "${!album_tag_field_array[${tag_field}]}" ]] ; then
			# Null, display: '<empty>'
			printf "%${SPACING}s${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}\n" \
			"" "${album_tag_field_array[${tag_field}]}:" " " "<empty>"
		else
			# Not empty, display tag value
			printf "%${SPACING}s${CYAN}%s${NORMAL}%s\n" \
			"" "${album_tag_field_array[${tag_field}]}:" " ${!album_tag_field_array[${tag_field}]}"
		fi

	done
}

# Display each tag field with a prompt to the user to
# "possibly" change the current tag using BASH's builtin
# support for GNU readline
__change_album_tags () {
	# Go through each tag field and display a prompt to the user
	# asking for a (possible) new tag value. Then, save the new
	# value.
	#
	# Also, display current tag being edited (UI enhancements)
	for tag_field in "${!album_tag_field_array[@]}" ; do

		# Set up spacing for the arrow displayed before
		# each tag field as well as set up spacing for each
		# tag field displayed as a prompt and initialize
		# the new tag fields to be saved
		case "${album_tag_field_array[${tag_field}]}" in
			ARTIST)
				spacing="9"
				arrow_spacing="7"
			;;
			ALBUM)
				spacing="10"
				arrow_spacing="8"
			;;
			DISCNUMBER)
				spacing="5"
				arrow_spacing="3"
			;;
			DATE)
				spacing="11"
				arrow_spacing="9"
			;;
			TRACKTOTAL)
				spacing="5"
				arrow_spacing="3"
			;;
			GENRE)
				spacing="10"
				arrow_spacing="8"
			;;
			RELEASETYPE)
				spacing="4"
				arrow_spacing="2"
			;;
			SOURCE)
				spacing="9"
				arrow_spacing="7"
			;;
			MASTERING)
				spacing="6"
				arrow_spacing="4"
			;;
		esac

		# Place cursor to current tag
		__place_cursor "${current_line}" "${arrow_spacing}"

		# Display arrow before current tag showing focus
		printf "${GREEN}%s${NORMAL}" "->"

		# Place cursor back at the bottom
		__place_cursor "${total_lines}" 0
	
		printf "%${spacing}s${CYAN}%s${NORMAL}" \
		"" "${album_tag_field_array[${tag_field}]}:"

		# Set up some default tag values for tag fields to be displayed
		# in the user prompt
		if [[ "${album_tag_field_array[${tag_field}]}" == "DISCNUMBER" && \
			  "${DISCNUMBER}" == "<multiple discs>" \
		   ]] ; then
			read -r -e -i "multiple" -p " " new_tag

		elif [[ "${album_tag_field_array[${tag_field}]}" == "TRACKTOTAL" && \
				"${DISCNUMBER}" == "<multiple discs>" ]] ; then
			read -r -e -i "multiple" -p " " new_tag

		elif [[ "${album_tag_field_array[${tag_field}]}" == "RELEASETYPE" && \
			( -z "${RELEASETYPE}" || \
			  "${RELEASETYPE}" == [Aa][Ll][Bb][Uu][Mm] ) \
		   ]] ; then
			read -r -e -i "Full Length" -p " " new_tag

		elif [[ "${album_tag_field_array[${tag_field}]}" == "RELEASETYPE" && \
			  ( "${RELEASETYPE}" == [Ss][Ii][Nn][Gg][Ll][Ee] || \
				"${RELEASETYPE}" == [Ee][Pp] ) \
			 ]] ; then
			read -r -e -i "EP" -p " " new_tag

		elif [[ "${album_tag_field_array[${tag_field}]}" == "DATE" && -n "${DATE}" ]] ; then
			read -r -e -i "${DATE:0:4}" -p " " new_tag
		elif [[ "${album_tag_field_array[${tag_field}]}" == "SOURCE" && -z "${SOURCE}" ]] ; then
			read -r -e -i "CD" -p " " new_tag
		elif [[ "${album_tag_field_array[${tag_field}]}" == "MASTERING" && -z "${MASTERING}" ]] ; then
			read -r -e -i "Lossless" -p " " new_tag
		else
			# Set up a local array of the current tag value.  This
			# value will have the first letter of each word uppercase
			#
			# Do not quote the album_tag_array below to allow word splitting
			local current_tag_value_array=( ${!album_tag_field_array[${tag_field}]} )

			# Change the above array to string (since '-i' in read doesn't handle
			# arrays well) as well as capitalize the first letter of each word
			local current_tag_value="${current_tag_value_array[@]^}"

			# Read in the new tag from the user with a prompt.  The text
			# displayed to the user enforces the first letter of each word
			# to be displayed uppercase
			read -r -e -i "${current_tag_value}" -p " " new_tag
		fi

		__place_cursor "${current_line}" "${arrow_spacing}"

		# If the user specified 'm', 'multi', or 'multiple' under the DISCNUMBER, go in to
		# multi disc mode
		if [[ "${album_tag_field_array[${tag_field}]}" == "DISCNUMBER" ]] ; then
			case "${new_tag}" in
				[Mm] | [Mm][Uu][Ll][Tt][Ii] | [Mm][Uu][Ll][Tt][Ii][Pp][Ll][Ee])
					# Choose which tracks are for which disc number
					__multi_disc
				;;
				*)
					# If the old tag is different from the new one
					if [[ "${DISCNUMBER}" != "${new_tag}" ]] ; then

						# If the old tag is empty
						if [[ -z "${DISCNUMBER}" ]] ; then
							printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}" \
							" " "*" " " "DISCNUMBER:" " " "${new_tag}" " <- " "<empty>"

						# If the new tag is empty
						elif [[ -z "${new_tag}" ]] ; then
							printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}" \
							" " "*" " " "DISCNUMBER:" " " "<empty>"

						# Display the old tag and the new tag differences
						else
							printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}" \
							" " "*" " " "DISCNUMBER:" " " "${new_tag}" " <- " "${DISCNUMBER}"
						fi

					# If the old and new tag are the same and the new
					# tag is empty
					elif [[ -z "${new_tag}" ]] ; then
						printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}" \
						" " "*" " " "DISCNUMBER:" " " "<empty>"

					# No difference from old tag to new tag, change the tag color
					# to green
					else
						printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}" \
						" " "*" " " "DISCNUMBER:" " " "${DISCNUMBER}"
					fi
					
					# Set the ${new_discnumber} to ${new_tag}
					new_discnumber="${new_tag}"
				;;
			esac

		# If the user specified 'm', 'multi', or 'multiple' under the
		# TRACKTOTAL tag, display '<multiple discs>', else proceed as normal
		elif [[ "${album_tag_field_array[${tag_field}]}" == "TRACKTOTAL" ]] ; then
			case "${new_tag}" in
				[Mm] | [Mm][Uu][Ll][Tt][Ii] | [Mm][Uu][Ll][Tt][Ii][Pp][Ll][Ee])
					printf "\r\033[K%3s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${YELLOW}%s${NORMAL}\n" \
					" " "*" " " "TRACKTOTAL:" " " "<multiple discs>"
				;;
				*)
					# If the old tag is different from the new one
					if [[ "${TRACKTOTAL}" != "${new_tag}" ]] ; then

						# If the old tag is empty
						if [[ -z "${TRACKTOTAL}" ]] ; then
							printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}" \
							" " "*" " " "TRACKTOTAL:" " " "${new_tag}" " <- " "<empty>"

						# If the new tag is empty
						elif [[ -z "${new_tag}" ]] ; then
							printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}" \
							" " "*" " " "TRACKTOTAL:" " " "<empty>"

						# Display the old tag and the new tag differences
						else
							printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}" \
							" " "*" " " "TRACKTOTAL:" " " "${new_tag}" " <- " "${TRACKTOTAL}"
						fi

					# If the old and new tag are the same and the new
					# tag is empty
					elif [[ -z "${new_tag}" ]] ; then
						printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}" \
						" " "*" " " "TRACKTOTAL:" " " "<empty>"

					# No difference from old tag to new tag, change the tag color
					# to green
					else
						printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}" \
						" " "*" " " "TRACKTOTAL:" " " "${TRACKTOTAL}"
					fi
					
					# Set the ${new_tracktotal} to ${new_tag}
					new_tracktotal="${new_tag}"
				;;
			esac
		else
			# If the old tag is different from the new one
			if [[ "${!album_tag_field_array[${tag_field}]}" != "${new_tag}" ]] ; then

				# If the old tag is empty
				if [[ -z "${!album_tag_field_array[${tag_field}]}" ]] ; then
					printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}" \
					" " "*" " " "${album_tag_field_array[${tag_field}]}:" " " "${new_tag}" " <- " "<empty>"

				# If the new tag is empty
				elif [[ -z "${new_tag}" ]] ; then
					printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}" \
					" " "*" " " "${album_tag_field_array[${tag_field}]}:" " " "<empty>"

				# Display the old tag and the new tag differences
				else
					printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}" \
					" " "*" " " "${album_tag_field_array[${tag_field}]}:" " " "${new_tag}" " <- " "${!album_tag_field_array[${tag_field}]}"
				fi

			# If the old and new tag are the same and the new
			# tag is empty
			elif [[ -z "${new_tag}" ]] ; then
				printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}" \
				" " "*" " " "${album_tag_field_array[${tag_field}]}:" " " "<empty>"

			# No difference from old tag to new tag, change the tag color
			# to green
			else
				printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}" \
				" " "*" " " "${album_tag_field_array[${tag_field}]}:" " " "${!album_tag_field_array[${tag_field}]}"
			fi

			# Save the new tag value to be used when tagging
			# the files
			case "${album_tag_field_array[${tag_field}]}" in
				ARTIST)
					new_artist="${new_tag}"
				;;
				ALBUM)
					new_album="${new_tag}"
				;;
				DISCNUMBER)
					# This will be set in the above iteration, so
					# no need to set it here
					:
				;;
				DATE)
					new_date="${new_tag}"
				;;
				TRACKTOTAL)
					# This will be set in the above iteration, so
					# no need to set it here
					:
				;;
				GENRE)
					new_genre="${new_tag}"
				;;
				RELEASETYPE)
					new_releasetype="${new_tag}"
				;;
				SOURCE)
					new_source="${new_tag}"
				;;
				MASTERING)
					new_mastering="${new_tag}"
				;;
			esac
		fi

		__place_cursor "${total_lines}" 0
		__clear_line
		((current_line++))

	done
}

# Display track listing with a prompt to set the DISCNUMBER for each
# track individually for multi-disc albums/releases
__multi_disc () {
	# Until user chooses "yes" at the prompt to save
	# multi disc information, don't move on
	until [[ "${multi_prompt}" == "true" ]] ; do

		# Clear the screen
		__clear_screen

		# Display current directory
		__top_banner

		# Show multi disc/tracktotal banner
		__multi_banner

		# Total lines used so far in the header/banner, including
		# the start of the first tag field
		total_lines="$(( ${#album_flacs_array[@]} + 6 ))"

		# Current line to the first file
		current_line="5"

		# Display a listing of FLAC files with the current DISCNUMBER and
		# TRACKTOTAL tag
		for flac in "${!album_flacs_array[@]}" ; do
			# Obtain DISCNUMBER and TRACKTOTAL tag into array
			mapfile -n0 -t tmp_disc_track_array < <(
				metaflac \
					--show-tag=DISCNUMBER \
					--show-tag=TRACKTOTAL \
					"${album_flacs_array[${flac}]}"
			)

			# Temporary DISCNUMBER
			tmp_discnumber="${tmp_disc_track_array[0]##*=}"

			# Temporary TRACKTOTAL
			tmp_tracktotal="${tmp_disc_track_array[1]##*=}"

			# Display current song with length and DISCNUMBER / TRACKTOTAL
			#
			# DISCNUMBER and TRACKTOTAL are both _NOT_ null
			if [[ -n "${tmp_discnumber}" && -n "${tmp_tracktotal}" ]] ; then
				printf "\r\033[K%s${CYAN}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${CYAN}%s${NORMAL}%s\n" \
				"    " "$(__song_length)" " [ " "${tmp_discnumber}" " : " "${tmp_tracktotal}" " ] ${album_flacs_array[${flac}]##*/}"
			# DISCNUMBER is null and TRACKTOTAL is not
			elif [[ -z "${tmp_discnumber}" && -n "${tmp_tracktotal}" ]] ; then
				printf "\r\033[K%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}%s${CYAN}%s${NORMAL}%s\n" \
				"    " "$(__song_length)" " [ " "?" " : " "${tmp_tracktotal}" " ] ${album_flacs_array[${flac}]##*/}"
			# TRACKTOTAL is null and DISCNUMBER is not
			elif [[ -n "${tmp_discnumber}" && -z "${tmp_tracktotal}" ]] ; then
				printf "\r\033[K%s${CYAN}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}%s\n" \
				"    " "$(__song_length)" " [ " "${tmp_discnumber}" " : " "?" " ] ${album_flacs_array[${flac}]##*/}"
			# Both DISCNUMBER and TRACKTOTAL are null
			else
				printf "\r\033[K%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}%s${RED}%s${NORMAL}%s\n" \
				"    " "$(__song_length)" " [ " "?" " : " "?" " ] ${album_flacs_array[${flac}]##*/}"
			fi
		done

		# Separator line
		printf "%s${BLUE}%s${NORMAL}\n" \
		" " "───────────────────────────────────────────────────"

		# Displays the current FLAC file to edit with the user prompt
		# asking for the new DISCNUMBER tag
		for flac in "${!album_flacs_array[@]}" ; do
			# Place cursor to current tag
			__place_cursor "${current_line}" 2
			printf "${GREEN}%s${NORMAL}" "->"
			__place_cursor "${total_lines}" 0

			# Grab the DISCNUMBER and TRACKTOTAL for the
			# current FLAC file
			mapfile -n0 -t old_disc_track_array < <(
				metaflac \
					--show-tag=DISCNUMBER \
					--show-tag=TRACKTOTAL \
					"${album_flacs_array[${flac}]}"
			)

			# Display DISCNUMBER prompt field
			printf "\r\033[K%s${CYAN}%s${NORMAL}" \
			" " "DISCNUMBER:"

			# Old DISCNUMBER
			old_discnumber="${old_disc_track_array[0]##*=}"

			# Prompt for new DISCNUMBER tag
			read -r -e -p " " -i "${old_discnumber}" new_discnumber

			__place_cursor "${total_lines}" 0

			if [[ -z "${new_discnumber}" ]] ; then
				read_discnumber="<empty>"
			else
				read_discnumber="${new_discnumber}"
			fi

			# Display TRACKTOTAL prompt field
			printf "\r\033[K%s${CYAN}%s${NORMAL}%s" \
			" " "TRACKTOTAL:" " ${read_discnumber} :"

			# Old TRACKTOTAL
			old_tracktotal="${old_disc_track_array[1]##*=}"

			# Prompt for new TRACKTOTAL tag
			read -r -e -p " " -i "${old_tracktotal}" new_tracktotal

			# Store the value of ${new_discnumber} and ${new_tracktotal}, along
			# with the song length and the filename, using :::: as the
			# delimeter:
			#
			#  <song length>::::<discnumber>::::<tracktotal>::::<filename>
			#
			# DISCNUMBER and TRACKTOTAL are both _NOT_ null
			if [[ -n "${new_discnumber}" && -n "${new_tracktotal}" ]] ; then
				multi_discnumber_array+=(
					"$(__song_length)::::${new_discnumber}::::${new_tracktotal}::::${album_flacs_array[${flac}]##*/}"
				)
			# TRACKTOTAL is null and DISCNUMBER is not
			elif [[ -n "${new_discnumber}" && -z "${new_tracktotal}" ]] ; then
				multi_discnumber_array+=(
					"$(__song_length)::::${new_discnumber}::::0::::${album_flacs_array[${flac}]##*/}"
				)
			# DISCNUMBER is null and TRACKTOTAL is not
			elif [[ -z "${new_discnumber}" && -n "${new_tracktotal}" ]] ; then
				multi_discnumber_array+=(
					"$(__song_length)::::0::::${new_tracktotal}::::${album_flacs_array[${flac}]##*/}"
				)
			# Both DISCNUMBER and TRACKTOTAL are null
			else
				multi_discnumber_array+=(
					"$(__song_length)::::0::::0::::${album_flacs_array[${flac}]##*/}"
				)
			fi

			__place_cursor "${current_line}" 0

			# DISCNUMBER and TRACKTOTAL are both _NOT_ null
			if [[ -n "${new_discnumber}" && -n "${new_tracktotal}" ]] ; then
				printf "\r\033[K%s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}\n" \
				"  " "*" " " "$(__song_length)" " [ " "${new_discnumber}" " : " "${new_tracktotal}" " ] " "${album_flacs_array[${flac}]##*/}"
			# DISCNUMBER is null and TRACKTOTAL is not
			elif [[ -z "${new_discnumber}" && -n "${new_tracktotal}" ]] ; then
				printf "\r\033[K%s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}\n" \
				"  " "*" " " "$(__song_length)" " [ " "?" " : " "${new_tracktotal}" " ] " "${album_flacs_array[${flac}]##*/}"
			# TRACKTOTAL is null and DISCNUMBER is not
			elif [[ -n "${new_discnumber}" && -z "${new_tracktotal}" ]] ; then
				printf "\r\033[K%s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}%s${GREEN}%s${NORMAL}\n" \
				"  " "*" " " "$(__song_length)" " [ " "${new_discnumber}" " : " "?" " ] " "${album_flacs_array[${flac}]##*/}"
			# Both DISCNUMBER and TRACKTOTAL are null
			else
				printf "\r\033[K%s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}%s${RED}%s${NORMAL}%s${GREEN}%s${NORMAL}\n" \
				"  " "*" " " "$(__song_length)" " [ " "?" " : " "?" " ] " "${album_flacs_array[${flac}]##*/}"
			fi

			((current_line++))
		done

		# Store a copy of the multi_discnumer_array for use when
		# tagging the files, because the multi_discnumber_array will
		# be empty by the time the script begins to tag the files.  This
		# also converts any DISCNUMBER and TRACKTOTAL values of 0 to null
		# (empty) to ensure proper tagging
		for i in "${multi_discnumber_array[@]}" ; do
			# Replace any 0's with null, done twice to ensure
			# all are done (// doesn't work here)
			i="${i/::::0::::/::::::::}"
			i="${i/::::0::::/::::::::}"

			# Add ${i} to new array
			multi_discnumber_change_array+=( "${i}" )
		done

		###########################################################
		# Sort by the new DISCNUMBER tag values with the filenames
		# to allow easy readability
		###########################################################

		# Clear the screen
		__clear_screen

		# Display current directory
		__top_banner

		# Show multi disc banner
		__multi_banner

		# Sort and display the new filenames with the new
		# DISCNUMBER tag
		#
		# Set the disc index to loop over.  This index is the value
		# tested against the value of each ${new_discnumber}.
		disc_index=0

		# Keep going until ${multi_discnumber_array[@]} is empty.  The inner for loop
		# will find a match for each value, unsetting an index for each match
		# eventually emptying the entire array
		while [[ -n "${multi_discnumber_array[@]}" ]] ; do

			# Every time the value of ${disc_index} is matched against ${sort_discnumber}
			# (starting from 0), print out the formatted filename.  For each match, remove
			# the array holding the file matched.
			for flac in "${!multi_discnumber_array[@]}" ; do

				# Specific values obtained from each indexed value
				sort_length="${multi_discnumber_array[${flac}]%%::::*}"

				sort_discnumber="${multi_discnumber_array[${flac}]#*::::}"
				sort_discnumber="${sort_discnumber%%::::*}"

				sort_tracktotal="${multi_discnumber_array[${flac}]%::::*}"
				sort_tracktotal="${sort_tracktotal##*::::}"

				sort_filename="${multi_discnumber_array[${flac}]##*::::}"

				# The user didn't enter a value for DISCNUMBER or the value was '0'
				if [[ "${sort_discnumber}" -eq "${disc_index}" && \
					( "${sort_discnumber}" -eq 0 && "${sort_tracktotal}" -ne 0 ) ]] ; then
					printf "%s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}\n" \
					"  " "*" " " "${sort_length}" " [ " "?" " : " "${sort_tracktotal}" " ] " "${sort_filename}"

					unset -v multi_discnumber_array[${flac}]

				# The user didn't enter a value for TRACKTOTAL or the value was '0'
				elif [[ "${sort_discnumber}" -eq "${disc_index}" && \
					( "${sort_discnumber}" -ne 0 && "${sort_tracktotal}" -eq 0 ) ]] ; then
					printf "%s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}%s${GREEN}%s${NORMAL}\n" \
					"  " "*" " " "${sort_length}" " [ " "${sort_discnumber}" " : " "?" " ] " "${sort_filename}"

					unset -v multi_discnumber_array[${flac}]

				# The user didn't enter a value for TRACKTOTAL and DISCNUMBER
				# or both values are '0'
				elif [[ "${sort_discnumber}" -eq "${disc_index}" && \
					( "${sort_discnumber}" -eq 0 && "${sort_tracktotal}" -eq 0 ) ]] ; then
					printf "%s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}%s${RED}%s${NORMAL}%s${GREEN}%s${NORMAL}\n" \
					"  " "*" " " "${sort_length}" " [ " "?" " : " "?" " ] " "${sort_filename}"

					unset -v multi_discnumber_array[${flac}]

				# Both TRACKTOTAL and DISCNUMBER are not null and not '0'
				elif [[ "${sort_discnumber}" -eq "${disc_index}" ]] ; then
					printf "%s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}\n" \
					"  " "*" " " "${sort_length}" " [ " "${sort_discnumber}" " : " "${sort_tracktotal}" " ] " "${sort_filename}"

					unset -v multi_discnumber_array[${flac}]
				fi
			done
			# Each time the loop finishes above, add one to the disc_index,
			# effectively sorting the ${new_discnumber} values with each filename
			((disc_index++))
		done

		# Separator line
		printf "%s${BLUE}%s${NORMAL}\n" \
		" " "───────────────────────────────────────────────────"

		__multi_disc_prompt
	done

	if [[ "${multi_prompt}" == "true" ]]  ; then
		# Reset ${current_line} to previous value
		#current_line="${current_line_backup}"
		current_line="5"

		# Reset ${total_lines} to previous value
		#total_lines="${total_lines_backup}"
		total_lines="16"

		# Clear the screen
		__clear_screen

		# Display current directory
		__top_banner

		# Show album banner
		__album_banner

		__display_album_tags

		# Separator line
		printf "%s${BLUE}%s${NORMAL}\n" \
		" " "───────────────────────────────────────────────────"

		__place_cursor "${current_line}" 0

		# Show the ARTIST, ALBUM, and DATE tag values (as well
		# as what has been changed), before returning to
		# the next album tag (DISCNUMBER)
		#
		# ARTIST
		if [[ "${ARTIST}" != "${new_artist}" ]] ; then

			# If the old tag is empty
			if [[ -z "${ARTIST}" ]] ; then
				printf "\r\033[K%7s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}\n" \
				" " "*" " " "ARTIST:" " " "${new_artist}" " <- " "<empty>"

			# If the new tag is empty
			elif [[ -z "${new_artist}" ]] ; then
				printf "\r\033[K%7s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}\n" \
				" " "*" " " "ARTIST:" " " "<empty>"

			# Display the old tag and the new tag differences
			else
				printf "\r\033[K%7s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}\n" \
				" " "*" " " "ARTIST:" " " "${new_artist}" " <- " "${ARTIST}"
			fi

		else
			# The old and new tag are the same
			printf "\r\033[K%7s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}\n" \
			" " "*" " " "ARTIST:" " " "${ARTIST}"
		fi

		# ALBUM
		if [[ "${ALBUM}" != "${new_album}" ]] ; then

			# If the old tag is empty
			if [[ -z "${ALBUM}" ]] ; then
				printf "\r\033[K%8s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}\n" \
				" " "*" " " "ALBUM:" " " "${new_album}" " <- " "<empty>"

			# If the new tag is empty
			elif [[ -z "${new_album}" ]] ; then
				printf "\r\033[K%8s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}\n" \
				" " "*" " " "ALBUM:" " " "<empty>"

			# Display the old tag and the new tag differences
			else
				printf "\r\033[K%8s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}\n" \
				" " "*" " " "ALBUM:" " " "${new_album}" " <- " "${ALBUM}"
			fi

		else
			# The old and new tag are the same
			printf "\r\033[K%8s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}\n" \
			" " "*" " " "ALBUM:" " " "${ALBUM}"
		fi

		# DISCNUMBER
		#
		# This tests for each DISCNUMBER value set for each FLAC file, and if
		# every file has a null value, then print empty, else show that there
		# are multiple discs
		for i in "${multi_discnumber_change_array[@]}" ; do
			# Obtain discnumber from array
			new_discnumber="${i#*::::}"
			new_discnumber="${new_discnumber%%::::*}"

			if [[ -n "${new_discnumber}" ]] ; then
				multiple_disc="true"
				break
			fi
		done

		# TRACKTOTAL
		#
		# This tests for each TRACKTOTAL value set for each FLAC file, and if
		# every file has a null value, then print empty, else show that there
		# are multiple discs
		for i in "${multi_discnumber_change_array[@]}" ; do
			# Obtain tracktotal from array
			new_tracktotal="${i%::::*}"
			new_tracktotal="${new_tracktotal##*::::}"

			if [[ -n "${new_tracktotal}" ]] ; then
				multiple_tracktotal="true"
				break
			fi
		done

		if [[ "${multiple_disc}" == "true" ]] ; then
			printf "\r\033[K%3s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${YELLOW}%s${NORMAL}\n" \
			" " "*" " " "DISCNUMBER:" " " "<multiple discs>"
		else
			printf "\r\033[K%3s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}\n" \
			" " "*" " " "DISCNUMBER:" " " "<empty>"
		fi

		# Reset the total lines back to 15 (includes the banner
		# album metadata and separator lines)
		total_lines="15"

		# Set the current line back to where it was before
		# the multi_disc function started ( +1 )
		current_line="$(( ${current_line} + 2 ))"

	fi
}

#  TRACK MANIPULATION
#==============================================
# Obtain the song length of the current FLAC file
__song_length () {
	# Obtain the total number of samples in current file
	total_samples="$(metaflac --show-total-samples "${album_flacs_array[${flac}]}")"

	# Obtain the sample rate in current file
	sample_rate="$(metaflac --show-sample-rate "${album_flacs_array[${flac}]}")"

	# This the total number of time in minutes (with the decimal [seconds]
	# moved to the right 3 places to account for non integer division
	total_time_in_minutes_with_decimal_moved="$(( ${total_samples} * 1000 / ${sample_rate} / 60 ))"

	# This is the total number of minutes (moves the decimal
	# back to the left 3 places and culls the 'decimal')
	total_minutes="$(( ${total_time_in_minutes_with_decimal_moved} / 1000 ))"

	# If the song is really short (less than a minute, do not offset the
	# string when obtaining just the remaining song time
	#
	# This is essentiall a percentage decimal (eg .832) but with the
	# decimal moved 3 places to the right
	if [[ "${total_minutes}" -eq 0 ]] ; then
		remaining_time_decimal_percentage="${total_time_in_minutes_with_decimal_moved}"
	else
		remaining_time_decimal_percentage="${total_time_in_minutes_with_decimal_moved:${#total_minutes}}"
	fi

	# Remove any leading zeroes from the remaining time so BASH can
	# successfully multiply the time without thinking the number is
	# an octal number
	#
	# (eg. 078 -> 78 or 008 -> 08)
	remaining_time_decimal_percentage="${remaining_time_decimal_percentage#0}"
	# (eg. 08 -> 8)
	remaining_time_decimal_percentage="${remaining_time_decimal_percentage#0}"

	# This is the remaining time 'percentage' multiplied by 60 to obtain the
	# total seconds (again, the decimal is moved 3 places to the right)
	remaining_seconds_unformatted="$(( ${remaining_time_decimal_percentage} * 60 ))"

	# Check the string length of the remaining seconds and prepend
	# the necessary amount of zeroes to ensure we always end
	# up with exactly five (5) characters (for consistency)
	case "${#remaining_seconds_unformatted}" in
		5)
			# Do nothing
			:
		;;
		4)
			remaining_seconds_unformatted="0${remaining_seconds_unformatted}"
		;;
		3)
			remaining_seconds_unformatted="00${remaining_seconds_unformatted}"
		;;
		2)
			remaining_seconds_unformatted="000${remaining_seconds_unformatted}"
		;;
		1)
			remaining_seconds_unformatted="0000${remaining_seconds_unformatted}"
		;;
		0)
			remaining_seconds_unformatted="00000${remaining_seconds_unformatted}"
		;;
		*)
			# Should NOT ever happen
			printf "%s\n" "This is a bug!" >&2
			exit 1
		;;
	esac

	# This is the total number of seconds obtained from the
	# above string: ${remaining_seconds_unformatted}, with the
	# extra 'decimal places' removed
	total_seconds="${remaining_seconds_unformatted:0:2}"

	# This is the value right after the remaining seconds last
	# digit, essentially a decimal number.  This will be
	# used to round up or down.
	round_up_value="${remaining_seconds_unformatted:2:1}"

	# If ${round_up_value} is greater or equal to five (5),
	# round up by adding one to the total seconds
	if [[ "${round_up_value}" -ge 5 ]] ; then
		total_seconds="${total_seconds#0}"
		((total_seconds++))
	fi

	# If the total seconds is only one digit (eg. 0-9), then
	# prepend a zero in front to allow consistent spacing
	if [[ "${#total_seconds}" -eq 1 ]] ; then
		total_seconds="0${total_seconds}"
	fi

	# If the total seconds is 60 (as a result of rounding up),
	# then set the total seconds to '00' (for formatting) and add
	# one to the total minutes
	if [[ "${total_seconds}" == "60" ]] ; then
		total_seconds=00
		((total_minutes++))
	fi

	# If ${total_minutes} is only one digit, prepend a space for consistent
	# formatting (allows songs 10 minutes or over to display in line with
	# shorter songs).
	if [[ "${#total_minutes}" -eq 1 ]] ; then
		total_minutes=" ${total_minutes}"
	fi

	# This will print the resultant song length
	printf "%s" "${total_minutes}:${total_seconds}"
}

# List the FLAC files in the current directory with
# the song length of each FLAC file
__list_tracks () {
	for flac in "${!album_flacs_array[@]}" ; do
		printf "\r\033[K%s${CYAN}%s${NORMAL}%s\n" \
		"    " "$(__song_length)" " ${album_flacs_array[${flac}]##*/}"
	done
}

__change_track_tags () {
	for flac in "${!album_flacs_array[@]}" ; do

		# Print current FLAC file with song length
		LENGTH="$(__song_length)"

		__place_cursor "${current_line}" 2
		printf "${GREEN}%s${NORMAL}" "->"
		__place_cursor "${total_lines}" 0

		# Tracknumber Tag
		TRACKNUMBER="$(metaflac --show-tag=TRACKNUMBER "${album_flacs_array[${flac}]}")"
		TRACKNUMBER="${TRACKNUMBER#*=}"

		# Title Tag
		TITLE="$(metaflac --show-tag=TITLE "${album_flacs_array[${flac}]}")"
		TITLE="${TITLE#*=}"

		# Set up a local array of the current tag value for TITLE.  This
		# value will have the first letter of each word uppercase
		#
		# Do NOT quote ${TITLE} value below to allow word splitting
		local current_title_value_array=( ${TITLE} )

		# Change the above array to string (since '-i' in read doesn't handle
		# arrays well) as well as capitalize the first letter of each word
		local current_title_value="${current_title_value_array[@]^}"

		# Display prompt field
		printf "\r\033[K%s${CYAN}%s${NORMAL}" \
		" " "TRACKNUMBER / TITLE:"

		# Read in new tracknumber and title tag via prompt.  The TITLE
		# value displayed to the user enforces the first letter of each
		# word to be displayed uppercase
		#
		# If TRACKNUMBER and TITLE are both empty, don't display
		# either tag (prevents space between two tags from appearing)
		if [[ -z "${TRACKNUMBER}" && -z "${TITLE}" ]] ; then
			read -r -e -a tracknumber_title_array -p " "

		# If TRACKNUMBER is empty, just display TITLE tag via
		# current_title_value
		elif [[ -z "${TRACKNUMBER}" ]] ; then
			read -r -e -a tracknumber_title_array -i "${current_title_value}" -p " "

		# Display both tags.  If TITLE is empty, the spacing will still
		# be correct (eg. '01 ' < space after track number)
		else
			read -r -e -a tracknumber_title_array -i "${TRACKNUMBER} ${current_title_value}" -p " "
		fi

		# Check to make sure tracknumber tag is a valid
		# tracknumber (integer) that is either 1 or 2 digits
		case "${tracknumber_title_array[0]}" in

			# Valid tracknumber (single digit so prepend a 0)
			[0-9])
				new_tracknumber="0${tracknumber_title_array[0]}"
				new_title="${tracknumber_title_array[@]:1}"
			;;

			# Valid tracknumber (double digit)
			[0-9][0-9])
				new_tracknumber="${tracknumber_title_array[0]}"
				new_title="${tracknumber_title_array[@]:1}"
			;;

			# Invalid tracknumber
			*)
				new_tracknumber=""
				new_title="${tracknumber_title_array[@]}"
			;;

		esac

		__place_cursor "${current_line}" 0

		# If both the new tags are NOT empty
		if [[ -n "${new_tracknumber}" && -n "${new_title}" ]] ; then
			printf "\r\033[K%s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}\n" \
			"  " "*" " " "${LENGTH}" " [ " "${new_tracknumber}" " ] " "${new_title}"

		# If the new tracknumber tag is empty
		elif [[ -z "${new_tracknumber}" && -n "${new_title}" ]] ; then
			printf "\r\033[K%s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}%s${GREEN}%s${NORMAL}\n" \
			"  " "*" " " "${LENGTH}" " [ " "??" " ] " "${new_title}"

		# If the new title tag is empty
		elif [[ -n "${new_tracknumber}" && -z "${new_title}" ]] ; then
			printf "\r\033[K%s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}\n" \
			"  " "*" " " "${LENGTH}" " [ " "${new_tracknumber}" " ] " "<empty>"

		# If both tags are empty
		else
			printf "\r\033[K%s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}%s${RED}%s${NORMAL}\n" \
			"  " "*" " " "${LENGTH}" " [ " "??" " ] " "<empty>"
		fi

		((current_line++))

		# If the new metadata is NOT equal to the original metadata (eg. it's
		# unchanged) and if the new metadata is NOT null, set that value into
		# its own array.  Otherwise, set a dummy value in order to preserve the
		# same number of array indices as ${album_flacs_array[@]}
		#
		# TRACKNUMBER
		if [[ -n "${new_tracknumber}" && "${new_tracknumber}" != "${TRACKNUMBER}" ]] ; then
			new_tracknumber_array+=( "${new_tracknumber}" )
		else
			new_tracknumber_array+=( "" )
		fi

		# TITLE
		if [[ -n "${new_title}" && "${new_title}" != "${TITLE}" ]] ; then
			new_title_array+=( "${new_title}" )
		else
			new_title_array+=( "" )
		fi

	done
}
__reset_track_listing () {
	# Reset ${current_line} to previous value
	current_line="${current_line_backup}"

	# Reset ${total_lines} to previous value
	total_lines="${total_lines_backup}"

	# This is the total # of lines to erase
	lines_to_move_up="$(( ${#album_flacs_array[@]} + 2 ))"

	# Travel up each line (to remove) and clear it
	for (( line=0 ; line < ${lines_to_move_up} ; line++ )) ; do
		printf "\033[A\033[K"
	done
}

#  RETAGGING
#==============================================
__retag_album () {
	# Set new ARTIST tag
	metaflac \
			--remove-tag=ARTIST \
			--set-tag=ARTIST="${new_artist}" \
			"${album_flacs_array[@]}"

	# Set new ALBUM tag
	metaflac \
			--remove-tag=ALBUM \
			--set-tag=ALBUM="${new_album}" \
			"${album_flacs_array[@]}"

	# Set new DISCNUMBER tag
	if [[ "${multi_prompt}" == "true" ]] ; then
		for flac in "${!album_flacs_array[@]}" ; do

			# Obtain discnumber from array
			tag_discnumber="${multi_discnumber_change_array[${flac}]#*::::}"
			tag_discnumber="${tag_discnumber%%::::*}"

			metaflac \
					--remove-tag=DISCNUMBER \
					--set-tag=DISCNUMBER="${tag_discnumber}" \
					"${album_flacs_array[${flac}]}"
		done
	else
		metaflac \
				--remove-tag=DISCNUMBER \
				--set-tag=DISCNUMBER="${new_discnumber}" \
				"${album_flacs_array[@]}"
	fi

	# Set new DATE tag
	metaflac \
			--remove-tag=DATE \
			--set-tag=DATE="${new_date}" \
			"${album_flacs_array[@]}"

	# Set new TRACKTOTAL tag
	if [[ "${multi_prompt}" == "true" ]] ; then
		for flac in "${!album_flacs_array[@]}" ; do

			# Obtain tracktotal from array
			tag_tracktotal="${multi_discnumber_change_array[${flac}]%::::*}"
			tag_tracktotal="${tag_tracktotal##*::::}"

			metaflac \
					--remove-tag=TRACKTOTAL \
					--set-tag=TRACKTOTAL="${tag_tracktotal}" \
					"${album_flacs_array[${flac}]}"
		done
	else
		metaflac \
				--remove-tag=TRACKTOTAL \
				--set-tag=TRACKTOTAL="${new_tracktotal}" \
				"${album_flacs_array[@]}"
	fi

	# Set new GENRE tag
	metaflac \
			--remove-tag=GENRE \
			--set-tag=GENRE="${new_genre}" \
			"${album_flacs_array[@]}"

	# Set new RELEASETYPE tag
	metaflac \
			--remove-tag=RELEASETYPE \
			--set-tag=RELEASETYPE="${new_releasetype}" \
			"${album_flacs_array[@]}"

	# Set new SOURCE tag
	metaflac \
			--remove-tag=SOURCE \
			--set-tag=SOURCE="${new_source}" \
			"${album_flacs_array[@]}"

	# Set new MASTERING tag
	metaflac \
			--remove-tag=MASTERING \
			--set-tag=MASTERING="${new_mastering}" \
			"${album_flacs_array[@]}"

	# Unset all the album tag values
	# Original tag values
	unset -v \
		ARTIST \
		ALBUM \
		DISCNUMBER \
		DATE \
		TRACKTOTAL \
		GENRE \
		RELEASETYPE \
		SOURCE \
		MASTERING

	# New tag values
	unset -v \
		new_artist \
		new_album \
		new_discnumber \
		new_date \
		new_tracktotal \
		new_genre \
		new_releasetype \
		new_source \
		new_mastering
}

__retag_tracks () {
	# Only set tags if there was a new tag specified, otherwise skip tagging
	# for that specific field and continue on
	for flac in "${!album_flacs_array[@]}" ; do

		# Obtain the TRACKNUMBER and TITLE tag from the current FLAC file via the
		# new_<tracknumber|title>_array.  The indices of this array match up
		# EXACTLY with the album_flacs_array above, removing the need for
		# associative arrays
		tracknumber_tag="${new_tracknumber_array[${flac}]}"
		title_tag="${new_title_array[${flac}]}"

		# Set new TRACKNUMBER tag
		if [[ -n "${tracknumber_tag}" ]] ; then
			metaflac \
					--remove-tag=TRACKNUMBER \
					--set-tag=TRACKNUMBER="${tracknumber_tag}" \
					"${album_flacs_array[${flac}]}"
		fi

		# Set new TITLE tag
		if [[ -n "${title_tag}" ]] ; then
			metaflac \
					--remove-tag=TITLE \
					--set-tag=TITLE="${title_tag}" \
					"${album_flacs_array[${flac}]}"
		fi

	done

	# Unset all the track tag values
	unset -v \
		TRACKNUMBER \
		TITLE \
		tracknumber_tag \
		title_tag \
		new_tracknumber_array \
		new_title_array
}

__tag_directory () {
	# Retag the files (album metadata) and
	# then the individually (track metadata)
	__retag_album
	__retag_tracks

	# Reset other prompt values and
	# start the current directory over
	unset -v \
		retag_album \
		retag_tracks \
		final_prompt
}

#  RENAME/MOVE MUSIC
#==============================================
__rename_music () {
	# This currently renames music as follows:
	#
	#  ARTIST/DATE - ALBUM/<DISCNUMBER> - TRACKNUMBER - TITLE.flac
	#
	#  Example:
	#  Kamelot/1995 - Eternity/02 - Black Tower.flac
	#                       or
	#  Kamelot/1995 - Eternity/1 - 02 - Black Tower.flac
	#
	# In order to allow the files to be correctly shown
	# on other filesystems (like FAT32), special
	# characters will be converted before being created.
	# This will NOT affect the METADATA of each FLAC file,
	# only the resultant filename/directory.  The characters
	# converted are as follows:
	#  .  <  >  :  \  /  |  ?  *
	#
	# If any of the above characters are found, they will be
	# replaced with an underscore (eg. _ ).

	# Set up the tags to be used when renaming the FLAC files
	# in the current directory.  This also entails scrubbing
	# troublesome characters.  We MUST re-obtain the tag
	# values to ensure we don't end up with null values	
	
	# This obtains ARTIST, DATE, and ALBUM
	mapfile -n0 -t rename_album_array < \
	<(metaflac \
		--show-tag=ARTIST \
		--show-tag=DATE \
		--show-tag=ALBUM \
		"${album_flacs_array[0]}"
	)

	# ARTIST - Remove special characters
	ARTIST="${rename_album_array[0]#*=}"
	ARTIST="${ARTIST/#./_}"
	ARTIST="${ARTIST//</_}"
	ARTIST="${ARTIST//>/_}"
	ARTIST="${ARTIST//:/_}"
	ARTIST="${ARTIST//\\/_}"
	ARTIST="${ARTIST//\//_}"
	ARTIST="${ARTIST//|/_}"
	ARTIST="${ARTIST//\?/_}"
	ARTIST="${ARTIST//\*/_}"

	# DATE
	DATE="${rename_album_array[1]#*=}"

	# ALBUM - Remove special characters
	ALBUM="${rename_album_array[2]#*=}"
	ALBUM="${ALBUM/#./_}"
	ALBUM="${ALBUM//</_}"
	ALBUM="${ALBUM//>/_}"
	ALBUM="${ALBUM//:/_}"
	ALBUM="${ALBUM//\\/_}"
	# Hyphen used below to change (for example):
	#  24bit/96kHz -> 24bit-96kHz
	ALBUM="${ALBUM//\//-}"
	ALBUM="${ALBUM//|/_}"
	ALBUM="${ALBUM//\?/_}"
	ALBUM="${ALBUM//\*/_}"

	# Make sure the directories exist before moving the
	# renamed files over
	renamed_file_location="${rename_directory}/${ARTIST}/${DATE} - ${ALBUM}"
	mkdir -p "${renamed_file_location}"

	for flac in "${!album_flacs_array[@]}" ; do

		# This obtains TRACKNUMBER, TITLE and DISCNUMBER
		mapfile -n0 -t rename_track_array < \
		<(metaflac \
			--show-tag=TRACKNUMBER \
			--show-tag=TITLE \
			--show-tag=DISCNUMBER \
			"${album_flacs_array[${flac}]}"
		)

		# TRACKNUMBER
		TRACKNUMBER="${rename_track_array[0]#*=}"

		# TITLE - Remove special characters
		TITLE="${rename_track_array[1]#*=}"
		TITLE="${TITLE/#./_}"
		TITLE="${TITLE//</_}"
		TITLE="${TITLE//>/_}"
		TITLE="${TITLE//:/_}"
		TITLE="${TITLE//\\/_}"
		TITLE="${TITLE//\//_}"
		TITLE="${TITLE//|/_}"
		TITLE="${TITLE//\?/_}"
		TITLE="${TITLE//\*/_}"

		# If the album had multiple discs obtain DISCNUMBER
		# and move the current FLAC file to the new location
		# using DISCNUMBER as the multi-disc separator
		if [[ "${multi_prompt}" == "true" ]] ; then
			DISCNUMBER="${rename_track_array[2]#*=}"
			mv "${album_flacs_array[${flac}]}" "${renamed_file_location}/${DISCNUMBER} - ${TRACKNUMBER} - ${TITLE}.flac"
		else
			# This will move the current FLAC file to the
			# new location _WITHOUT_ using DISCNUMBER as the
			# multi-disc separator
			mv "${album_flacs_array[${flac}]}" "${renamed_file_location}/${TRACKNUMBER} - ${TITLE}.flac"
		fi

	done

	# Check if the current directory directory has any leftover files
	# and move them over if there are
	empty_directory=( "${flac_directories[${current_directory}]}"/**/*.* )

	if [[ -f "${empty_directory[0]}" ]] ; then
		# Move any extra files into the new directory
		mv "${flac_directories[${current_directory}]}"/*.* "${renamed_file_location}/"

		# Delete the current directory (now empty)
		rmdir "${flac_directories[${current_directory}]}"
	fi
}

#  PROMPTS
#==============================================
__save_album_tags_prompt () {
	printf "%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}%s" \
	" Save " "album" " METADATA? [" "Yes" "/" "No" "] "
	while read -e -r ; do
		case "${REPLY}" in
			[Yy] | [Yy][Ee][Ss] | "")
				retag_album="true"
				break
			;;
			[Nn] | [Nn][Oo])
				retag_album="false"
				break
			;;
			*)
				# Unknown answer, clear prompt
				printf "\033[A\033[K"

				# Restate prompt
				printf "%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}%s" \
				" Save " "album" " METADATA? [" "Yes" "/" "No" "] "
			;;
		esac
	done
}

__multi_disc_prompt () {
	printf "%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}%s" \
	" Save " "multi-disc" " METADATA? [" "Yes" "/" "No" "] "
	while read -e -r ; do
		case "${REPLY}" in
			[Yy] | [Yy][Ee][Ss] | "")
				multi_prompt="true"
				break
			;;
			[Nn] | [Nn][Oo])
				multi_prompt="false"
				break
			;;
			*)
				# Unknown answer, clear prompt
				printf "\033[A\033[K"

				# Restate prompt
				printf "%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}%s" \
				" Save " "multi-disc" " METADATA? [" "Yes" "/" "No" "] "
			;;
		esac
	done
}

__save_track_tags_prompt () {
	printf "\n\033[K%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}%s" \
	" Save " "track" " METADATA? [" "Yes" "/" "No" "] "
	while read -e -r ; do
		case "${REPLY}" in
			[Yy] | [Yy][Ee][Ss] | "")
				retag_tracks="true"
				break
			;;
			[Nn] | [Nn][Oo])
				retag_tracks="false"
				break
			;;
			*)
				# Unknown answer, clear prompt
				printf "\033[A\033[K"

				# Restate prompt
				printf "%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}%s" \
				" Save " "track" " METADATA? [" "Yes" "/" "No" "] "
			;;
		esac
	done
}

__tag_directory_final_prompt () {
	# Separator line
	printf "%s${RED}%s${NORMAL}\n" \
	" " "───────────────────────────────────────────────────"

	# The total number of lines to be used so far
	total_lines=$(( ${current_line} + 4 ))

	# Place the next separator line below the upcoming prompt
	__place_cursor "${total_lines}" 0

	# Separator line
	printf "%s${RED}%s${NORMAL}\n" \
	" " "───────────────────────────────────────────────────"

	# Return the cursor positions to where it would normally
	# be (after the first separator line
	__place_cursor "$(( ${total_lines} - 1 ))" 0

	# Prompt
	printf "%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}%s" \
	" Tag " "all" " files in current directory? [" "Yes" "/" "No" "] "

	# Place the next separator line below the upcoming prompt
	__place_cursor "$(( ${total_lines} - 1 ))" 47

	while read -r ; do
		case "${REPLY}" in
			[Yy] | [Yy][Ee][Ss] | "")
				final_prompt="true"
				break
			;;
			[Nn] | [Nn][Oo])
				final_prompt="false"

				# Reset other prompts and start the
				# current directory over
				unset -v \
					retag_album \
					retag_tracks \
					final_prompt

				break
			;;
			*)
				# Unknown answer, clear prompt
				printf "\033[A\033[K"

				# Restate prompt
				printf "%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}%s" \
				" Tag " "all" " files in current directory? [" "Yes" "/" "No" "] "
			;;
		esac
	done

}

#---END FUNCTIONS--------------------------------------------------


#------------------------------------------------------------------
#   BEGIN SCRIPT
#------------------------------------------------------------------
# Check if version info was requested
case "${1}" in
	-v | --version)
		__version
		exit 0
	;;
esac

# Save screen settings
__save_screen

# This is the directory to process FLACs
directory="${1%/}"

# Find all the FLAC files and store in an array
total_flacs_array=( "${directory}"/**/*.[Ff][Ll][Aa][Cc] )

# Find all the directories to process (ie. albums)
for i in "${total_flacs_array[@]}" ; do

	# If the current directory is not equal to the last
	# processed directory, then save it to an array as
	# a new directory
	if [[ "${processed_directory}" != "${i%/*}" ]] ; then
		flac_directories+=( "${i%/*}" )
	fi

	# Save current directory into variable for testing on
	# next iteration
	processed_directory="${i%/*}"

done

# Grab the number of directories found to process
number_of_directories="${#flac_directories[@]}"

# This will iterate through each directory and on each
# directory, do some processing
for current_directory in "${!flac_directories[@]}" ; do

	#------------------------------------------------------------------
	#   CURRENT DIRECTORY START
	#------------------------------------------------------------------
	# Until user chooses "yes" at the final prompt
	# go through and start the process of tagging the album
	# from the beginning.  If "yes", go to the next album/directory
	until [[ "${final_prompt}" == "true" ]] ; do

		# If user said no for final prompt, clear all the lines
		# and start over with tagging process
		if [[ "${final_prompt}" == "false" ]] ; then
			# Clear the screen
			__clear_screen
		fi

		#------------------------------------------------------------------
		#   ALBUM METADATA
		#------------------------------------------------------------------
		# Until user chooses "yes" at the prompt to save
		# album metadata, don't move on to track metadata
		until [[ "${retag_album}" == "true" ]] ; do

			# Find all the FLAC files in the current processed directory
			album_flacs_array=( "${flac_directories[${current_directory}]}"/**/*.[Ff][Ll][Aa][Cc] )

			# Clear the screen
			__clear_screen

			# Display current directory
			__top_banner

			# Show album banner
			__album_banner

			# Total lines used so far in the header/banner, including
			# the start of the first tag field
			total_lines="4"

			# Display the album metadata with the current
			# tags found for each field
			__display_album_tags

			# Separator line
			printf "%s${BLUE}%s${NORMAL}\n" \
			" " "───────────────────────────────────────────────────"

			# Total number of lines used thus far (banner, tag fields, spacing)
			total_lines=15

			# The current line is the current tag field being processed (with ->)
			# used in the below function when reading/setting new tags
			current_line=5

			# Display each album tag field with user prompt
			__change_album_tags

			# Prompt user whether album metadata should be saved and
			# continue with the file metadata
			__save_album_tags_prompt

		done

		#---END ALBUM METADATA---------------------------------------------


		#------------------------------------------------------------------
		#   TRACK METADATA
		#------------------------------------------------------------------
		# Show track banner
		__track_banner

		# The current line is the total lines so far (without the FLAC file
		# listing plus 4 for spacing)
		current_line="$(( ${total_lines} + 4 ))"

		# Backup to the above, to allow correct lines if user specifies
		# no to prompts
		current_line_backup="${current_line}"

		# Total number of lines used thus far (banner, tag fields,
		# spacing, # of flac files)
		total_lines="$(( ${total_lines} + ${#album_flacs_array[@]} + 5 ))"

		# Backup to the above, to allow correct lines if user specifies
		# no to prompts
		total_lines_backup="${total_lines}"

		# Until user chooses "yes" at the prompt to save
		# track metadata, don't move on to final prompt
		until [[ "${retag_tracks}" == "true" ]] ; do

			# If user said no for previous prompt, clear the lines
			# displayed (individual tracks) and start the tagging
			# process over
			if [[ "${retag_tracks}" == "false" ]] ; then
				__reset_track_listing
			fi

			# Show a listing of FLAC files in current directory
			__list_tracks

			# Separator line
			printf "%s${BLUE}%s${NORMAL}\n" \
			" " "───────────────────────────────────────────────────"

			# Display each track tag field to change with user prompt
			__change_track_tags

			# Prompt user whether file metadata should be saved
			# continuing on with final prompt
			__save_track_tags_prompt

		done

		#---END TRACK METADATA---------------------------------------------


		#------------------------------------------------------------------
		#   FINAL PROMPT
		#------------------------------------------------------------------
		# Final prompt to decide whether metadata should be
		# applied to all files in the current directory
		__tag_directory_final_prompt

		#---END FINAL PROMPT-----------------------------------------------

	done

	# We can retag the files in the current directory.
	if [[ "${final_prompt}" == "true" ]] ; then
		__tag_directory
	fi

	#------------------------------------------------------------------
	#   RENAME/MOVE MUSIC
	#------------------------------------------------------------------

	# Skip a line to allow the bottom red line to be visible
	printf "\n"

	# This function will rename the tagged music (in the current
	# directory)
	__rename_music

	#---END RENAME/MOVE MUSIC------------------------------------------


	#---END CURRENT DIRECTORY------------------------------------------

done

# Restore screen settings
__restore_screen

#---END SCRIPT-----------------------------------------------------
exit 0
