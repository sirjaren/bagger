#!/usr/bin/env bash

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You can follow development of this script on Github at:
# https://github.com/sirjaren/bagger
#
# Please submit requests/changes/patches and/or comments
#-----------------------------------------------------------------

# Enable BASH 4's globstar
shopt -s globstar

# Script version
VERSION="0.1"

# Enable colors
BLUE="\033[34m"
GREEN="\033[32m"
RED="\033[31m"
CYAN="\033[36m"
MAGENTA="\033[35m"
YELLOW="\033[33m"
NORMAL="\033[0m"

#------------------------------------------------------------------
#   FUNCTIONS
#------------------------------------------------------------------

#  DISPLAY VERSION
#==============================================
__version () {
	printf "%s\n" "Version: ${VERSION}"
}

#  SCREEN MANIPULATION
#==============================================
__save_screen () {
	printf "\033[?1049h"
}

__restore_screen () {
	printf "\033[r\033[?1049l"
}

__clear_screen () {
	printf "\033[H\033[2J"
}
__place_cursor () {
	printf "\033[${1};${2}H"
}

__clear_line () {
	printf "\033[K"
}

#  BANNERS
#==============================================
__top_banner () {
	printf "${GREEN}%52s\r%s${CYAN}%s${NORMAL}\n" \
	"${flac_directories[${current_directory}]##*/}" " " "[$(( ${current_directory} + 1 ))/${number_of_directories}]"

	# Separator line
	printf "%s${BLUE}%s${NORMAL}\n" \
	" " "───────┬────────────────┬──────────────────────────"
}


__album_banner () {
	printf "%8s${BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BLUE}%s${NORMAL}\n" \
	"" "│" " " "Album Metadata" " " "│"

	printf "%8s${BLUE}%s${NORMAL}\n" \
	"" "└────────────────┘"
}

__track_banner () {
	printf "%s${BLUE}%s${NORMAL}\n" \
	" " "──┬───────────────────────────┬────────────────────"

	printf "%3s${BLUE}%s${NORMAL}%s${YELLOW}%s${NORMAL}%s${BLUE}%s${NORMAL}\n" \
	"" "│" " " "Individual Track Metadata" " " "│"

	printf "%3s${BLUE}%s${NORMAL}\n" \
	"" "└───────────────────────────┘"
}

#  ALBUM MANIPULATION
#==============================================
__display_album_tags () {
	# Store all the tag fields into an array
	album_tag_field_array=( ARTIST ALBUM DISCNUMBER DATE TRACKTOTAL GENRE RELEASETYPE SOURCE MASTERING )

	# Go through each FLAC file in the current directory and obtain all the
	# tags that will be changed album-wise (batch tag).
	mapfile -n0 -t metaflac_tag_array < \
	<(metaflac \
		--show-tag=ARTIST \
		--show-tag=ALBUM \
		--show-tag=DISCNUMBER \
		--show-tag=DATE \
		--show-tag=TRACKTOTAL \
		--show-tag=GENRE \
		--show-tag=RELEASETYPE \
		--show-tag=SOURCE \
		--show-tag=MASTERING \
		"${album_flacs_array[@]}"
	)

	# For each tag field (eg. ARTIST, DATE, etc), test for a value in one of the FLAC files
	# in the current directory.  If the specified tag is found, start looking for the next
	# tag field's value.  If a tag cannot found, try the next file (continuing on until all
	# the files have been tried).
	for tag_field in "${!album_tag_field_array[@]}" ; do

		# ${tag} is a value like: ARTIST=Kamelot
		for tag in "${metaflac_tag_array[@]##*.[Ff][Ll][Aa][Cc]:}" ; do

			# Removes tag value from ${tag}
			# (eg. ARTIST=Kamelot -> ARTIST)
			current_tag_field="${tag%=*}"

			# If the current tag field from the top most for loop is the same as
			# the ${current_tag_field} variable (upper case), then test for the
			# tag value from that field.
			if [[ "${album_tag_field_array[${tag_field}]}" == "${current_tag_field^^}" ]] ; then

				# If tag value exists, store it in the appropriate tag
				# field
				if [[ -n "${tag#*=}" ]] ; then

					case "${album_tag_field_array[${tag_field}]}" in
						ARTIST)
							ARTIST="${tag#*=}"
							break
						;;
						ALBUM)
							ALBUM="${tag#*=}"
							break
						;;
						DISCNUMBER)
							DISCNUMBER="${tag#*=}"
							break
						;;
						DATE)
							DATE="${tag#*=}"
							break
						;;
						TRACKTOTAL)
							TRACKTOTAL="${tag#*=}"

							# This is obtained by the # of FLAC files
							# in the current directory, so skip grabbing
							# the current value via FLAC files
							#TRACKTOTAL_DYNAMIC="${#album_flacs_array[@]}"
							break
						;;
						GENRE)
							GENRE="${tag#*=}"
							break
						;;
						RELEASETYPE)
							RELEASETYPE="${tag#*=}"
							break
						;;
						SOURCE)
							SOURCE="${tag#*=}"
							break
						;;
						MASTERING)
							MASTERING="${tag#*=}"
							break
						;;
					esac

				fi

			fi

		done

	done

	# Go through each tag field and print the tag field as well as the current
	# value for that field
	for tag_field in "${!album_tag_field_array[@]}" ; do

		# Set up spacing for each tag field
		case "${album_tag_field_array[${tag_field}]}" in
			ARTIST)
				SPACING="9"
			;;
			ALBUM)
				SPACING="10"
			;;
			DISCNUMBER)
				SPACING="5"
			;;
			DATE)
				SPACING="11"
			;;
			TRACKTOTAL)
				SPACING="5"
			;;
			GENRE)
				SPACING="10"
			;;
			RELEASETYPE)
				SPACING="4"
			;;
			SOURCE)
				SPACING="9"
			;;
			MASTERING)
				SPACING="6"
			;;
		esac

		# If the current tag field is TRACKTOTAL, display the value obtained
		# from the FLAC file as well as the value determined from the number
		# of FLAC files
		if [[ "${album_tag_field_array[${tag_field}]}" == "TRACKTOTAL" ]] ; then

			if [[ -n "${TRACKTOTAL}" ]] ; then
				# Display TRACKTOTAL value and # of FLAC files
				printf "%${SPACING}s${CYAN}%s${NORMAL}%s${YELLOW}%s${NORMAL}\n" \
				"" "TRACKTOTAL:" " ${TRACKTOTAL} " "(${#album_flacs_array[@]} songs found)"
			else
				# Display '<empty>' and # of FLAC files
				printf "%${SPACING}s${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}%s${YELLOW}%s${NORMAL}\n" \
				"" "TRACKTOTAL:" " " "<empty>" " " "(${#album_flacs_array[@]} songs found)"
			fi

		# If other tag field's values are null, display <empty>, else display current value
		elif [[ -z "${!album_tag_field_array[${tag_field}]}" ]] ; then
			# Null, display: '<empty>'
			printf "%${SPACING}s${CYAN}%s${NORMAL}%s${MAGENTA}%s${NORMAL}\n" \
			"" "${album_tag_field_array[${tag_field}]}:" " " "<empty>"
		else
			# Not empty, display tag value
			printf "%${SPACING}s${CYAN}%s${NORMAL}%s\n" \
			"" "${album_tag_field_array[${tag_field}]}:" " ${!album_tag_field_array[${tag_field}]}"
		fi

	done
}

# Display each tag field with a prompt to the user to
# "possibly" change the current tag using BASH's builtin
# support for GNU readline
__change_album_tags () {
	# Go through each tag field and display a prompt to the user
	# asking for a (possible) new tag value. Then, save the new
	# value.
	#
	# Also, display current tag being edited (UI enhancements)
	for tag_field in "${!album_tag_field_array[@]}" ; do

		# Set up spacing for the arrow displayed before
		# each tag field as well as set up spacing for each
		# tag field displayed as a prompt and initialize
		# the new tag fields to be saved
		case "${album_tag_field_array[${tag_field}]}" in
			ARTIST)
				spacing="9"
				arrow_spacing="7"
				new_artist="dont tag"
			;;
			ALBUM)
				spacing="10"
				arrow_spacing="8"
				new_album="dont tag"
			;;
			DISCNUMBER)
				spacing="5"
				arrow_spacing="3"
				new_discnumber="dont tag"
			;;
			DATE)
				spacing="11"
				arrow_spacing="9"
				new_date="dont tag"
			;;
			TRACKTOTAL)
				spacing="5"
				arrow_spacing="3"
				new_tracktotal="dont tag"
			;;
			GENRE)
				spacing="10"
				arrow_spacing="8"
				new_genre="dont tag"
			;;
			RELEASETYPE)
				spacing="4"
				arrow_spacing="2"
				new_releasetype="dont tag"
			;;
			SOURCE)
				spacing="9"
				arrow_spacing="7"
				new_source="dont tag"
			;;
			MASTERING)
				spacing="6"
				arrow_spacing="4"
				new_mastering="dont tag"
			;;
		esac

		# Place cursor to current tag
		__place_cursor "${current_line}" "${arrow_spacing}"

		# Display arrow before current tag showing focus
		printf "${GREEN}%s${NORMAL}" "->"

		# Place cursor back at the bottom
		__place_cursor "${total_lines}" 0
	
		printf "%${spacing}s${CYAN}%s${NORMAL}" \
		"" "${album_tag_field_array[${tag_field}]}:"

		# Read in the new tag from the user with a prompt
		read -r -e -i "${!album_tag_field_array[${tag_field}]}" -p " " new_tag

		__place_cursor "${current_line}" "${arrow_spacing}"

		# If the old tag is different from the new one
		if [[ "${!album_tag_field_array[${tag_field}]}" != "${new_tag}" ]] ; then

			# If the old tag is empty
			if [[ -z "${!album_tag_field_array[${tag_field}]}" ]] ; then
				printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}" \
				" " "*" " " "${album_tag_field_array[${tag_field}]}:" " " "${new_tag}" " <- " "<empty>"

			# If the new tag is empty
			elif [[ -z "${new_tag}" ]] ; then
				printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}" \
				" " "*" " " "${album_tag_field_array[${tag_field}]}:" " " "<empty>"

			# Display the old tag and the new tag differences
			else
				printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}" \
				" " "*" " " "${album_tag_field_array[${tag_field}]}:" " " "${new_tag}" " <- " "${!album_tag_field_array[${tag_field}]}"
			fi

		# If the old and new tag are the same and the new
		# tag is empty
		elif [[ -z "${new_tag}" ]] ; then
			printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}" \
			" " "*" " " "${album_tag_field_array[${tag_field}]}:" " " "<empty>"

		# No difference from old tag to new tag, change the tag color
		# to green
		else
			printf "\r\033[K%${arrow_spacing}s${MAGENTA}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}" \
			" " "*" " " "${album_tag_field_array[${tag_field}]}:" " " "${!album_tag_field_array[${tag_field}]}"
		fi

		# If the value of the new tag is different from the old tag, save the
		# new metadata, else skip it (this allows us to NOT retag files unnecessarily)
		if [[ "${!album_tag_field_array[${tag_field}]}" != "${new_tag}" ]] ; then

			# Save the new tag value to be used when tagging
			# the files
			case "${album_tag_field_array[${tag_field}]}" in
				ARTIST)
					new_artist="${new_tag}"
				;;
				ALBUM)
					new_album="${new_tag}"
				;;
				DISCNUMBER)
					new_discnumber="${new_tag}"
				;;
				DATE)
					new_date="${new_tag}"
				;;
				TRACKTOTAL)
					new_tracktotal="${new_tag}"
				;;
				GENRE)
					new_genre="${new_tag}"
				;;
				RELEASETYPE)
					new_releasetype="${new_tag}"
				;;
				SOURCE)
					new_source="${new_tag}"
				;;
				MASTERING)
					new_mastering="${new_tag}"
				;;
			esac

		fi

		__place_cursor "${total_lines}" 0
		__clear_line
		((current_line++))

	done
}

#  TRACK MANIPULATION
#==============================================
# Obtain the song length of the current FLAC file
__song_length () {
	# Obtain the total number of samples in current file
    total_samples="$(metaflac --show-total-samples "${album_flacs_array[${flac}]}")"

    # Obtain the sample rate in current file
    sample_rate="$(metaflac --show-sample-rate "${album_flacs_array[${flac}]}")"

    # This the total number of time in minutes (with the decimal [seconds]
    # moved to the right 3 places to account for non integer division
    total_time_in_minutes_with_decimal_moved="$(( ${total_samples} * 1000 / ${sample_rate} / 60 ))"

    # This is the total number of minutes (moves the decimal
    # back to the left 3 places and culls the 'decimal')
    total_minutes="$(( ${total_time_in_minutes_with_decimal_moved} / 1000 ))"

    # If the song is really short (less than a minute, do not offset the
    # string when obtaining just the remaining song time
    #
    # This is essentiall a percentage decimal (eg .832) but with the
    # decimal moved 3 places to the right
    if [[ "${total_minutes}" -eq 0 ]] ; then
        remaining_time_decimal_percentage="${total_time_in_minutes_with_decimal_moved}"
    else
        remaining_time_decimal_percentage="${total_time_in_minutes_with_decimal_moved:${#total_minutes}}"
    fi

    # Remove any leading zeroes from the remaining time so BASH can
    # successfully multiply the time without thinking the number is
    # an octal number
    #
    # (eg. 078 -> 78 or 008 -> 08)
    remaining_time_decimal_percentage="${remaining_time_decimal_percentage#0}"
    # (eg. 08 -> 8)
    remaining_time_decimal_percentage="${remaining_time_decimal_percentage#0}"

    # This is the remaining time 'percentage' multiplied by 60 to obtain the
    # total seconds (again, the decimal is moved 3 places to the right)
    remaining_seconds_unformatted="$(( ${remaining_time_decimal_percentage} * 60 ))"

    # Check the string length of the remaining seconds and prepend
    # the necessary amount of zeroes to ensure we always end
    # up with exactly five (5) characters (for consistency)
    case "${#remaining_seconds_unformatted}" in
        5)
            # Do nothing
            :
        ;;
        4)
            remaining_seconds_unformatted="0${remaining_seconds_unformatted}"
        ;;
        3)
            remaining_seconds_unformatted="00${remaining_seconds_unformatted}"
        ;;
        2)
            remaining_seconds_unformatted="000${remaining_seconds_unformatted}"
        ;;
        1)
            remaining_seconds_unformatted="0000${remaining_seconds_unformatted}"
        ;;
        0)
            remaining_seconds_unformatted="00000${remaining_seconds_unformatted}"
        ;;
        *)
            # Should NOT ever happen
            printf "%s\n" "This is a bug!"
            exit 1
        ;;
    esac

    # This is the total number of seconds obtained from the
    # above string: ${remaining_seconds_unformatted}, with the
    # extra 'decimal places' removed
    total_seconds="${remaining_seconds_unformatted:0:2}"

    # This is the value right after the remaining seconds last
    # digit, essentially a decimal number.  This will be
    # used to round up or down.
    round_up_value="${remaining_seconds_unformatted:2:1}"

    # If ${round_up_value} is greater or equal to five (5),
    # round up by adding one to the total seconds
    if [[ "${round_up_value}" -ge 5 ]] ; then
        total_seconds="${total_seconds#0}"
        ((total_seconds++))
    fi

    # If the total seconds is only one digit (eg. 0-9), then
    # prepend a zero in front to allow consistent spacing
    if [[ "${#total_seconds}" -eq 1 ]] ; then
        total_seconds="0${total_seconds}"
    fi

    # If the total seconds is 60 (as a result of rounding up),
    # then set the total seconds to '00' (for formatting) and add
    # one to the total minutes
    if [[ "${total_seconds}" == "60" ]] ; then
        total_seconds=00
        ((total_minutes++))
    fi

    # This will print the resultant song length
    printf "%s" "${total_minutes}:${total_seconds}"
}

# List the FLAC files in the current directory with
# the song length of each FLAC file
__list_tracks () {
	for flac in "${!album_flacs_array[@]}" ; do
		printf "\r\033[K%s${BLUE}%s${NORMAL}%s\n" \
		"    " "$(__song_length)" " ${album_flacs_array[${flac}]##*/}"
	done
}

__change_track_tags () {
	for flac in "${!album_flacs_array[@]}" ; do

		# Print current FLAC file with song length
		LENGTH="$(__song_length)"

		__place_cursor "${current_line}" 2
		printf "${GREEN}%s${NORMAL}" "->"
		__place_cursor "${total_lines}" 0

		# Tracknumber Tag
		TRACKNUMBER="$(metaflac --show-tag=TRACKNUMBER "${album_flacs_array[${flac}]}")"
		TRACKNUMBER="${TRACKNUMBER#*=}"

		# Title Tag
		TITLE="$(metaflac --show-tag=TITLE "${album_flacs_array[${flac}]}")"
		TITLE="${TITLE#*=}"

		printf "\r\033[K%s${CYAN}%s${NORMAL}" \
		" " "TRACKNUMBER / TITLE:"

		# Read in new tracknumber and title tag via prompt
		#
		# If TRACKNUMBER and TITLE are both empty, don't display
		# either tag (prevents space between two tags from appearing)
		if [[ -z "${TRACKNUMBER}" && -z "${TITLE}" ]] ; then
			read -r -e -a tracknumber_title_array -p " "

		# If TRACKNUMBER is empty, just display TITLE tag
		elif [[ -z "${TRACKNUMBER}" ]] ; then
			read -r -e -a tracknumber_title_array -i "${TITLE}" -p " "

		# Display both tags.  If TITLE is empty, the spacing will still
		# be correct (eg. '01 ' < space after track number)
		else
			read -r -e -a tracknumber_title_array -i "${TRACKNUMBER} ${TITLE}" -p " "
		fi

		# Check to make sure tracknumber tag is a valid
		# tracknumber (integer) that is either 1 or 2 digits
		case "${tracknumber_title_array[0]}" in

			# Valid tracknumber (single digit so prepend a 0)
			[0-9])
				new_tracknumber="0${tracknumber_title_array[0]}"
				new_title="${tracknumber_title_array[@]:1}"
			;;

			# Valid tracknumber (double digit)
			[0-9][0-9])
				new_tracknumber="${tracknumber_title_array[0]}"
				new_title="${tracknumber_title_array[@]:1}"
			;;

			# Invalid tracknumber
			*)
				new_tracknumber=""
				new_title="${tracknumber_title_array[@]}"
			;;

		esac

		__place_cursor "${current_line}" 0

		# If both the new tags are NOT empty
		if [[ -n "${new_tracknumber}" && -n "${new_title}" ]] ; then
			printf "\r\033[K%s${MAGENTA}%s${NORMAL}%s${BLUE}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}\n" \
			"  " "*" " " "${LENGTH}" " [ " "${new_tracknumber}" " ] " "${new_title}"

		# If the new tracknumber tag is empty
		elif [[ -z "${new_tracknumber}" && -n "${new_title}" ]] ; then
			printf "\r\033[K%s${MAGENTA}%s${NORMAL}%s${BLUE}%s${NORMAL}%s${RED}%s${NORMAL}%s${GREEN}%s${NORMAL}\n" \
			"  " "*" " " "${LENGTH}" " [ " "??" " ] " "${new_title}"

		# If the new title tag is empty
		elif [[ -n "${new_tracknumber}" && -z "${new_title}" ]] ; then
			printf "\r\033[K%s${MAGENTA}%s${NORMAL}%s${BLUE}%s${NORMAL}%s${CYAN}%s${NORMAL}%s${RED}%s${NORMAL}\n" \
			"  " "*" " " "${LENGTH}" " [ " "${new_tracknumber}" " ] " "<empty>"

		# If both tags are empty
		else
			printf "\r\033[K%s${MAGENTA}%s${NORMAL}%s${BLUE}%s${NORMAL}%s${RED}%s${NORMAL}%s${RED}%s${NORMAL}\n" \
			"  " "*" " " "${LENGTH}" " [ " "??" " ] " "<empty>"
		fi

		((current_line++))

		# If the new metadata is NOT equal to the original metadata (eg. it's
		# unchanged) and if the new metadata is NOT null, set that value into
		# its own array.  Otherwise, set a dummy value of "dont tag" in order
		# to preserve the same number of array indices as ${album_flacs_array[@]}
		#
		# TRACKNUMBER
		if [[ -n "${new_tracknumber}" && "${new_tracknumber}" != "${TRACKNUMBER}" ]] ; then
			new_tracknumber_array+=( "${new_tracknumber}" )
		else
			new_tracknumber_array+=( "dont tag" )
		fi

		# TITLE
		if [[ -n "${new_title}" && "${new_title}" != "${TITLE}" ]] ; then
			new_title_array+=( "${new_title}" )
		else
			new_title_array+=( "dont tag" )
		fi

	done
}
__reset_track_listing () {
	# Reset ${current_line} to previous value
	current_line="${current_line_backup}"

	# Reset ${total_lines} to previous value
	total_lines="${total_lines_backup}"

	# This is the total # of lines to erase
	lines_to_move_up="$(( ${#album_flacs_array[@]} + 2 ))"

	# Travel up each line (to remove) and clear it
	for (( line=0 ; line < ${lines_to_move_up} ; line++ )) ; do
		printf "\033[A\033[K"
	done
}

#  RETAGGING
#==============================================
__retag_album () {
	# Only set tags if there was a new tag specified (eg. ${new_artist} doesn't
	# equal "dont tag"), otherwise skip tagging for that specific field and continue on

	# Set new ARTIST tag
	if [[ "${new_artist}" != "dont tag" ]] ; then
		metaflac \
				--remove-tag=ARTIST \
				--set-tag=ARTIST="${new_artist}" \
				"${album_flacs_array[@]}"
	fi

	# Set new ALBUM tag
	if [[ "${new_album}" != "dont tag" ]] ; then
		metaflac \
				--remove-tag=ALBUM \
				--set-tag=ALBUM="${new_album}" \
				"${album_flacs_array[@]}"
	fi

	# Set new DISCNUMBER tag
	if [[ "${new_discnumber}" != "dont tag" ]] ; then
		metaflac \
				--remove-tag=DISCNUMBER \
				--set-tag=DISCNUMBER="${new_discnumber}" \
				"${album_flacs_array[@]}"
	fi

	# Set new DATE tag
	if [[ "${new_date}" != "dont tag" ]] ; then
		metaflac \
				--remove-tag=DATE \
				--set-tag=DATE="${new_date}" \
				"${album_flacs_array[@]}"
	fi

	# Set new TRACKTOTAL tag
	if [[ "${new_tracktotal}" != "dont tag" ]] ; then
		metaflac \
				--remove-tag=TRACKTOTAL \
				--set-tag=TRACKTOTAL="${new_tracktotal}" \
				"${album_flacs_array[@]}"
	fi

	# Set new GENRE tag
	if [[ "${new_genre}" != "dont tag" ]] ; then
		metaflac \
				--remove-tag=GENRE \
				--set-tag=GENRE="${new_genre}" \
				"${album_flacs_array[@]}"
	fi

	# Set new RELEASETYPE tag
	if [[ "${new_releasetype}" != "dont tag" ]] ; then
		metaflac \
				--remove-tag=RELEASETYPE \
				--set-tag=RELEASETYPE="${new_releasetype}" \
				"${album_flacs_array[@]}"
	fi

	# Set new SOURCE tag
	if [[ "${new_source}" != "dont tag" ]] ; then
		metaflac \
				--remove-tag=SOURCE \
				--set-tag=SOURCE="${new_source}" \
				"${album_flacs_array[@]}"
	fi

	# Set new MASTERING tag
	if [[ "${new_mastering}" != "dont tag" ]] ; then
		metaflac \
				--remove-tag=MASTERING \
				--set-tag=MASTERING="${new_mastering}" \
				"${album_flacs_array[@]}"
	fi
}

__retag_tracks () {
	# Only set tags if there was a new tag specified, otherwise skip tagging
	# for that specific field and continue on
	for flac in "${!album_flacs_array[@]}" ; do

		# Obtain the TRACKNUMBER and TITLE tag from the current FLAC file via the
		# new_<tracknumber|title>_array.  The indices of this array match up
		# EXACTLY with the album_flacs_array above, removing the need for
		# associative arrays
		tracknumber_tag="${new_tracknumber_array[${flac}]}"
		title_tag="${new_title_array[${flac}]}"

		# Set new TRACKNUMBER tag
		if [[ "${tracknumber_tag}" != "dont tag" ]] ; then
			metaflac \
					--remove-tag=TRACKNUMBER \
					--set-tag=TRACKNUMBER="${tracknumber_tag}" \
					"${album_flacs_array[${flac}]}"
		fi

		# Set new TITLE tag
		if [[ "${title_tag}" != "dont tag" ]] ; then
			metaflac \
					--remove-tag=TITLE \
					--set-tag=TITLE="${title_tag}" \
					"${album_flacs_array[${flac}]}"
		fi

	done
}

__tag_directory () {
	# Retag the files (album metadata) and
	# then the individually (track metadata)
	__retag_album
	__retag_tracks

	# Reset other prompts and start the
	# current directory over
	unset retag_album
	unset retag_tracks
	unset final_prompt
}

#  PROMPTS
#==============================================
__save_album_tags_prompt () {
	printf "%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}%s" \
	" Save " "album" " METADATA? [" "Yes" "/" "No" "] "
	while read -e -r ; do
		case "${REPLY}" in
			[Yy] | [Yy][Ee][Ss] | "")
				retag_album="true"
				break
			;;
			[Nn] | [Nn][Oo])
				retag_album="false"
				break
			;;
			*)
				# Unknown answer, clear prompt
				printf "\033[A\033[K"

				# Restate prompt
				printf "%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}%s" \
				" Save " "album" " METADATA? [" "Yes" "/" "No" "] "
			;;
		esac
	done
}

__save_track_tags_prompt () {
	printf "\n\033[K%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}%s" \
	" Save " "track" " METADATA? [" "Yes" "/" "No" "] "
	while read -e -r ; do
		case "${REPLY}" in
			[Yy] | [Yy][Ee][Ss] | "")
				retag_tracks="true"
				break
			;;
			[Nn] | [Nn][Oo])
				retag_tracks="false"
				break
			;;
			*)
				# Unknown answer, clear prompt
				printf "\033[A\033[K"

				# Restate prompt
				printf "%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}%s" \
				" Save " "track" " METADATA? [" "Yes" "/" "No" "] "
			;;
		esac
	done
}

__tag_directory_final_prompt () {
	# Separator line
	printf "%s${RED}%s${NORMAL}\n" \
	" " "───────────────────────────────────────────────────"

	# The total number of lines to be used so far
	total_lines=$(( ${current_line} + 4 ))

	# Place the next separator line below the upcoming prompt
	__place_cursor "${total_lines}" 0

	# Separator line
	printf "%s${RED}%s${NORMAL}\n" \
	" " "───────────────────────────────────────────────────"

	# Return the cursor positions to where it would normally
	# be (after the first separator line
	__place_cursor "$(( ${total_lines} - 1 ))" 0

	# Prompt
	printf "%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}%s" \
	" Tag " "all" " files in current directory? [" "Yes" "/" "No" "] "

	# Place the next separator line below the upcoming prompt
	__place_cursor "$(( ${total_lines} - 1 ))" 47

	while read -r ; do
		case "${REPLY}" in
			[Yy] | [Yy][Ee][Ss] | "")
				final_prompt="true"
				break
			;;
			[Nn] | [Nn][Oo])
				final_prompt="false"

				# Reset other prompts and start the
				# current directory over
				unset retag_album
				unset retag_tracks
				unset final_prompt

				break
			;;
			*)
				# Unknown answer, clear prompt
				printf "\033[A\033[K"

				# Restate prompt
				printf "%s${CYAN}%s${NORMAL}%s${GREEN}%s${NORMAL}%s${RED}%s${NORMAL}%s" \
				" Tag " "all" " files in current directory? [" "Yes" "/" "No" "] "
			;;
		esac
	done
}

#---END FUNCTIONS--------------------------------------------------


#------------------------------------------------------------------
#   BEGIN SCRIPT
#------------------------------------------------------------------
# Check if version info was requested
case "${1}" in
	-v | --version)
		__version
		exit 0
	;;
esac

# Save screen settings
__save_screen

# This is the directory to process FLACs
directory="${1%/}"

# Find all the FLAC files and store in an array
total_flacs_array=( "${directory}"/**/*.[Ff][Ll][Aa][Cc] )

# Find all the directories to process (ie. albums)
for i in "${total_flacs_array[@]}" ; do

	# If the current directory is not equal to the last
	# processed directory, then save it to an array as
	# a new directory
	if [[ "${processed_directory}" != "${i%/*}" ]] ; then
		flac_directories+=( "${i%/*}" )
	fi

	# Save current directory into variable for testing on
	# next iteration
	processed_directory="${i%/*}"

done

# Grab the number of directories found to process
number_of_directories="${#flac_directories[@]}"

# This will iterate through each directory and on each
# directory, do some processing
for current_directory in "${!flac_directories[@]}" ; do

	#------------------------------------------------------------------
	#   CURRENT DIRECTORY START
	#------------------------------------------------------------------
	# Until user chooses "yes" at the final prompt
	# go through and start the process of tagging the album
	# from the beginning.  If "yes", go to the next album/directory
	until [[ "${final_prompt}" == "true" ]] ; do

		# If user said no for final prompt, clear all the lines
		# and start over with tagging process
		if [[ "${final_prompt}" == "false" ]] ; then
			# Clear the screen
			__clear_screen
		fi

		#------------------------------------------------------------------
		#   ALBUM METADATA
		#------------------------------------------------------------------
		# Until user chooses "yes" at the prompt to save
		# album metadata, don't move on to track metadata
		until [[ "${retag_album}" == "true" ]] ; do

			# Find all the FLAC files in the current processed directory
			album_flacs_array=( "${flac_directories[${current_directory}]}"/**/*.[Ff][Ll][Aa][Cc] )

			# Clear the screen
			__clear_screen

			# Display current directory
			__top_banner

			# Show album banner
			__album_banner

			# Total lines used so far in the header/banner, including
			# the start of the first tag field
			total_lines="4"

			# Display the album metadata with the current
			# tags found for each field
			__display_album_tags

			# Separator line
			printf "%s${BLUE}%s${NORMAL}\n" \
			" " "───────────────────────────────────────────────────"

			# Total number of lines used thus far (banner, tag fields, spacing)
			total_lines=15

			# The current line is the current tag field being processed (with ->)
			# used in the below function when reading/setting new tags
			current_line=5

			# Display each album tag field with user prompt
			__change_album_tags

			# Prompt user whether album metadata should be saved and
			# continue with the file metadata
			__save_album_tags_prompt

		done

		#---END ALBUM METADATA---------------------------------------------


		#------------------------------------------------------------------
		#   TRACK METADATA
		#------------------------------------------------------------------
		# Show track banner
		__track_banner

		# The current line is the total lines so far (without the FLAC file
		# listing plus 4 for spacing)
		current_line="$(( ${total_lines} + 4 ))"

		# Backup to the above, to allow correct lines if user specifies
		# no to prompts
		current_line_backup="${current_line}"

		# Total number of lines used thus far (banner, tag fields,
		# spacing, # of flac files)
		total_lines="$(( ${total_lines} + ${#album_flacs_array[@]} + 5 ))"

		# Backup to the above, to allow correct lines if user specifies
		# no to prompts
		total_lines_backup="${total_lines}"

		# Until user chooses "yes" at the prompt to save
		# track metadata, don't move on to final prompt
		until [[ "${retag_tracks}" == "true" ]] ; do

			# If user said no for previous prompt, clear the lines
			# displayed (individual tracks) and start the tagging
			# process over
			if [[ "${retag_tracks}" == "false" ]] ; then
				__reset_track_listing
			fi

			# Show a listing of FLAC files in current directory
			__list_tracks

			# Separator line
			printf "%s${BLUE}%s${NORMAL}\n" \
			" " "───────────────────────────────────────────────────"

			# Display each track tag field to change with user prompt
			__change_track_tags

			# Prompt user whether file metadata should be saved
			# continuing on with final prompt
			__save_track_tags_prompt

		done

		#---END TRACK METADATA---------------------------------------------


		#------------------------------------------------------------------
		#   FINAL PROMPT
		#------------------------------------------------------------------
		# Final prompt to decide whether metadata should be
		# applied to all files in the current directory
		__tag_directory_final_prompt

		#---END FINAL PROMPT-----------------------------------------------

	done

	# We can retag the files in the current directory.
	if [[ "${final_prompt}" == "true" ]] ; then
		__tag_directory
	fi

	#---END CURRENT DIRECTORY------------------------------------------

done

# Restore screen settings
__restore_screen

#---END SCRIPT-----------------------------------------------------
exit 0
